{"version":3,"sources":["../static/js/Markets.3a84af72.chunk.js","components/markets/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/legend/ScrollableLegendModel.js","../node_modules/echarts/lib/component/legend/ScrollableLegendView.js","../node_modules/echarts/lib/component/legend/scrollableLegendAction.js","components/markets/MarketOverview.js","components/common/RingPieChart.js"],"names":["webpackJsonp","2041","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","priceGraph","markets","price","volumeGraph","volume","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_reactIntl","_reactRedux","_markets","_i18n","_MarketOverview","_MarketOverview2","_loaders","_api","_LineChart","_LineChart2","_RingPieChart","_RingPieChart2","Markets","_React$Component","_this2","_this","getPrototypeOf","loadMarketData","mark","_callee","wrap","_context","prev","next","loadPriceData","Client","getMarkets","sent","setState","stop","formatTableData","intl","data","sort","a","b","rank","map","val","push","name","pair","volumeNative","formatNumber","volumePercentage","maximumFractionDigits","minimumFractionDigits","slice","customizedColumn","title","formatMessage","id","dataIndex","sorter","width","filterDropdown","_props","tableData","column","createElement","className","tu","style","height","TronLoader","keysData","format","time","date","Component","mapDispatchToProps","connect","pure","injectIntl","2090","getSymbolSize","idx","symbolSize","getItemVisual","Array","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","inherits","_default","2091","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","2115","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","2116","SymbolDraw","symbolCtor","group","_symbolCtor","symbolNeedsDraw","point","isIgnore","clipShape","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","oldData","_data","SymbolCtor","diff","newIdx","getItemLayout","symbolEl","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","position","el","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","2127","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","lineStyle","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","2128","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","coordSysClipShape","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","2129","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","2130","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","2131","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","2132","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","2133","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","2136","layout","componentModel","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getWidth","getHeight","rect","getLayoutRect","layoutBox","positionElement","makeBackground","formatUtil","normalizeCssArray","_layout","box","2137","Model","_model","isNameSpecified","LegendModel","extendComponentModel","layoutMode","ignoreSize","parentModel","mergeDefaultAndTheme","selected","mergeOption","superCall","optionUpdated","_updateData","legendData","hasSelected","isSelected","select","potentialData","availableNames","eachRawSeries","seriesName","isPotential","legendDataProvider","names","concat","_availableNames","rawData","dataItem","unSelect","toggleSelected","hasOwnProperty","indexOf","show","orient","left","top","align","backgroundColor","borderColor","borderRadius","borderWidth","itemGap","itemWidth","itemHeight","inactiveColor","textStyle","selectedMode","tooltip","2138","dispatchSelectAction","dispatchAction","dispatchHighlightAction","dataName","getZr","storage","getDisplayList","dispatchDownplayAction","_listComponent","layoutUtil","curry","extendComponentView","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","maxSize","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","createHashMap","selectMode","newline","getSeriesByName","legendSymbolType","itemGroup","_createItem","set","indexOfName","textStyleModel","itemIcon","tooltipModel","legendGlobalTooltipModel","textX","textAlign","formatter","content","replace","Text","setTextStyle","textFill","getTextColor","textVerticalAlign","hitRect","getBoundingRect","invisible","formatterParams","componentType","legendIndex","componentIndex","$vars","eachChild","child","__legendDataIndex","contentRect","2193","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","2194","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","newOption","targetList","valueList","percent","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","animationType","mixin","2195","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","2196","_targetList","_selectTargetMap","reduce","targetMap","2197","updateDataSelected","uid","from","seriesId","toggleItemSelected","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","2198","actionInfos","actionInfo","registerAction","eachComponent","mainType","subType","query","2199","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","2200","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","2201","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","2202","legendModels","findComponents","filterSelf","2203","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","lineId","myChart","getInstanceByDom","document","getElementById","lineChart","xAxis","series","formatDate","formatTime","setOption","initLine","2206","legendFilter","registerSubTypeDefaulter","2207","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","model","isItemSelected","2208","filterSeries","2209","mergeAndNormalizeLayoutParams","raw","getOrient","index","mergeLayoutParam","getLayoutParams","ScrollableLegendModel","setScrollDataIndex","scrollDataIndex","pageButtonItemGap","pageButtonGap","pageButtonPosition","pageFormatter","pageIcons","horizontal","vertical","pageIconColor","pageIconInactiveColor","pageIconSize","pageTextStyle","animationDurationUpdate","extraOpt","inputPositionParams","2210","LegendView","WH","XY","ScrollableLegendView","_currentIndex","_containerGroup","_controllerGroup","_showController","__rectSize","createPageButton","iconIdx","pageDataIndexName","icon","createIcon","onclick","me","_pageGo","controllerGroup","pageTextStyleModel","containerGroup","orientIdx","wh","hw","yx","controllerRect","showController","contentPos","containerPos","controllerPos","retrieve2","pageInfo","_getPageInfo","pageIndex","contentPosition","_updatePageInfoView","to","legendId","canJump","childOfName","pageText","total","pageCount","isString","getItemRect","itemRect","clone","xy","pagePrevDataIndex","pageNextDataIndex","targetItemGroup","currDataIndex","containerRectSize","ceil","itemLoc","floor","winRect","startIdx","children","intersect","startItem","startRect","2211","2462","_extends","assign","_antd","MarketOverview","_Component","onInputChange","e","searchText","onReset","onSearch","reg","RegExp","filterDropdownVisible","filtered","record","match","split","toLowerCase","filter","setColumn","compare","property","obj1","obj2","Input","ref","ele","searchInput","placeholder","onChange","onPressEnter","Button","onClick","filterIcon","Icon","onFilterDropdownVisibleChange","visible","focus","columns","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","col","temp","return","Table","dataSource","2463","_toConsumableArray","arr","arr2","RingPieReact","pieId","ringPieChart","legend","sortObj","pairData","exchanges","subCount","finalExchanges","finalPairData","initPie"],"mappings":"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","file":"static/js/Markets.3a84af72.chunk.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 2041:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(14);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(17);var _reactRedux=__webpack_require__(16);var _markets=__webpack_require__(738);var _i18n=__webpack_require__(13);var _MarketOverview=__webpack_require__(2462);var _MarketOverview2=_interopRequireDefault(_MarketOverview);var _loaders=__webpack_require__(38);var _api=__webpack_require__(15);var _LineChart=__webpack_require__(2203);var _LineChart2=_interopRequireDefault(_LineChart);var _RingPieChart=__webpack_require__(2463);var _RingPieChart2=_interopRequireDefault(_RingPieChart);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Markets=function(_React$Component){_inherits(Markets,_React$Component);function Markets(){var _this2=this;_classCallCheck(this,Markets);var _this=_possibleConstructorReturn(this,(Markets.__proto__||Object.getPrototypeOf(Markets)).call(this));_this.loadMarketData=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var markets;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this.props.loadPriceData();_context.next=3;return _api.Client.getMarkets();case 3:markets=_context.sent;_this.setState({markets:markets});case 5:case\"end\":return _context.stop();}}},_callee,_this2);}));_this.formatTableData=function(markets){var intl=_this.props.intl;var data=[];markets.sort(function(a,b){return a.rank-b.rank;});if(markets.length){markets.map(function(val){data.push({key:val.rank,rank:val.rank,name:val.name,pair:val.pair,volumeNative:intl.formatNumber(val.volumeNative)+' TRX',volumePercentage:intl.formatNumber(val.volumePercentage,{maximumFractionDigits:2,minimumFractionDigits:2})+'%',price:'$'+intl.formatNumber(val.price,{maximumFractionDigits:8})});});}return data.slice(0,99);};_this.customizedColumn=function(){var intl=_this.props.intl;var column=[{title:intl.formatMessage({id:'rank'}),dataIndex:'rank',key:'rank',sorter:true,width:'5%'},{title:intl.formatMessage({id:'exchange'}),dataIndex:'name',key:'name',filterDropdown:true},{title:intl.formatMessage({id:'pair'}),dataIndex:'pair',key:'pair',width:'12%'},{title:intl.formatMessage({id:'volume'}),dataIndex:'volumeNative',key:'volumeNative',width:'14%'},{title:'%',dataIndex:'volumePercentage',key:'volumePercentage',width:'8%'},{title:intl.formatMessage({id:'price'}),dataIndex:'price',key:'price',width:'10%'}];return column;};_this.state={priceGraph:[],volumeGraph:[],markets:[]};return _this;}_createClass(Markets,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadMarketData();}},{key:\"render\",value:function render(){var _props=this.props,intl=_props.intl,priceGraph=_props.priceGraph,volumeGraph=_props.volumeGraph;var markets=this.state.markets;var tableData=this.formatTableData(markets);var column=this.customizedColumn();return _react2.default.createElement(\"main\",{className:\"container header-overlap pb-3\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_price_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},priceGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:priceGraph,keysData:['time','close'],format:{time:true,date:true}}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_volume_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},volumeGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:volumeGraph,keysData:['time','volume'],format:{time:true}})))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Trade Volume\"),' Top 10'),_react2.default.createElement(_RingPieChart2.default,{style:{height:700},data:markets}))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(_MarketOverview2.default,{tableData:tableData,column:column}))));}}]);return Markets;}(_react2.default.Component);function mapStateToProps(state){return{priceGraph:state.markets.price,volumeGraph:state.markets.volume};}var mapDispatchToProps={loadPriceData:_markets.loadPriceData};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(Markets));\n\n/***/ }),\n\n/***/ 2090:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar _symbol = __webpack_require__(376);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(41);\n\nvar _number = __webpack_require__(50);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(728);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2091:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(241);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(9);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 2115:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\n__webpack_require__(2127);\n\n__webpack_require__(2128);\n\nvar visualSymbol = __webpack_require__(2131);\n\nvar layoutPoints = __webpack_require__(2132);\n\nvar dataSample = __webpack_require__(2133);\n\n__webpack_require__(729);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 2116:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(41);\n\nvar SymbolClz = __webpack_require__(2090);\n\nvar _util = __webpack_require__(9);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2127:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(378);\n\nvar SeriesModel = __webpack_require__(377);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // 拐点图形类型\n    symbol: 'emptyCircle',\n    // 拐点图形大小\n    symbolSize: 4,\n    // 拐点图形旋转控制\n    symbolRotate: null,\n    // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n    showSymbol: true,\n    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    showAllSymbol: false,\n    // 是否连接断点\n    connectNulls: false,\n    // 数据过滤，'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2128:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(9);\n\nvar SymbolDraw = __webpack_require__(2116);\n\nvar SymbolClz = __webpack_require__(2090);\n\nvar lineAnimationDiff = __webpack_require__(2129);\n\nvar graphic = __webpack_require__(41);\n\nvar modelUtil = __webpack_require__(28);\n\nvar _poly = __webpack_require__(2130);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(718);\n\nvar _helper = __webpack_require__(2091);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2129:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(2091);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2130:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(57);\n\nvar vec2 = __webpack_require__(45);\n\nvar fixClipWithShadow = __webpack_require__(726);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 2131:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2132:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(9);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(727);\n\nvar _dataStackHelper = __webpack_require__(241);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2133:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2136:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(98);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(70);\n\nvar graphic = __webpack_require__(41);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 2137:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar Model = __webpack_require__(79);\n\nvar _model = __webpack_require__(28);\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 4,\n    show: true,\n    // 布局方式，默认为水平布局，可选为：\n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // 水平对齐\n    // 'auto' | 'left' | 'right'\n    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 图例边框颜色\n    borderColor: '#ccc',\n    borderRadius: 0,\n    // 图例边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 图例内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 各个item之间的间隔，单位px，默认为10，\n    // 横向布局时为水平间隔，纵向布局时为纵向间隔\n    itemGap: 10,\n    // 图例图形宽度\n    itemWidth: 25,\n    // 图例图形高度\n    itemHeight: 14,\n    // 图例关闭时候的颜色\n    inactiveColor: '#ccc',\n    textStyle: {\n      // 图例文字颜色\n      color: '#333'\n    },\n    // formatter: '',\n    // 选择模式，默认开启图例开关\n    selectedMode: true,\n    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n    // selected: null,\n    // 图例内容（详见legend.data，数组中每一项代表一个item\n    // data: [],\n    // Tooltip 相关配置\n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2138:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar _symbol = __webpack_require__(376);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(41);\n\nvar _listComponent = __webpack_require__(2136);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(98);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2193:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\n__webpack_require__(2194);\n\n__webpack_require__(2197);\n\nvar createDataSelectAction = __webpack_require__(2198);\n\nvar dataColor = __webpack_require__(2199);\n\nvar pieLayout = __webpack_require__(2200);\n\nvar dataFilter = __webpack_require__(2202);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 2194:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar createListSimply = __webpack_require__(2195);\n\nvar zrUtil = __webpack_require__(9);\n\nvar modelUtil = __webpack_require__(28);\n\nvar _number = __webpack_require__(50);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(2196);\n\nvar _dataProvider = __webpack_require__(152);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2195:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(380);\n\nvar List = __webpack_require__(379);\n\nvar _util = __webpack_require__(9);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2196:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2197:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(41);\n\nvar ChartView = __webpack_require__(718);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2198:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2199:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(9);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2200:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(50);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(2201);\n\nvar zrUtil = __webpack_require__(9);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2201:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(123);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2202:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2203:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(17);var _chartConfig=__webpack_require__(714);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(55);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(2115);__webpack_require__(715);__webpack_require__(716);var _reactRedux=__webpack_require__(16);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{if((val[keysData[0]]+\"\").length===10)_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));if((val[keysData[0]]+\"\").length===13)_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]));}}else{_chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);}_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 2206:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\n__webpack_require__(2137);\n\n__webpack_require__(2207);\n\n__webpack_require__(2138);\n\nvar legendFilter = __webpack_require__(2208);\n\nvar Component = __webpack_require__(100);\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n\n/***/ 2207:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n\n/***/ 2208:\n/***/ (function(module, exports) {\n\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2209:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar LegendModel = __webpack_require__(2137);\n\nvar _layout = __webpack_require__(98);\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2210:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(41);\n\nvar layoutUtil = __webpack_require__(98);\n\nvar LegendView = __webpack_require__(2138);\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2211:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n/***/ }),\n\n/***/ 2462:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(13);var _api=__webpack_require__(15);var _Links=__webpack_require__(21);var _reactIntl=__webpack_require__(17);var _Price=__webpack_require__(71);var _antd=__webpack_require__(745);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var MarketOverview=function(_Component){_inherits(MarketOverview,_Component);function MarketOverview(){_classCallCheck(this,MarketOverview);var _this=_possibleConstructorReturn(this,(MarketOverview.__proto__||Object.getPrototypeOf(MarketOverview)).call(this));_this.onInputChange=function(e){_this.setState({searchText:e.target.value});};_this.onReset=function(){_this.setState({searchText:''},function(){_this.onSearch();});};_this.onSearch=function(){var tableData=_this.props.tableData;var searchText=_this.state.searchText;var reg=new RegExp(searchText,'gi');_this.setState({filterDropdownVisible:false,filtered:!!searchText,data:tableData.map(function(record){var match=record.name.match(reg);if(!match){return null;}return _extends({},record,{name:_react2.default.createElement(\"span\",null,record.name.split(new RegExp(\"(?<=\"+searchText+\")|(?=\"+searchText+\")\",'i')).map(function(text,i){return text.toLowerCase()===searchText.toLowerCase()?_react2.default.createElement(\"span\",{key:i,className:\"highlight\"},text):text// eslint-disable-line\n;}))});}).filter(function(record){return!!record;})});};_this.setColumn=function(column){function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}var filter={filterDropdown:_react2.default.createElement(\"div\",{className:\"custom-filter-dropdown\"},_react2.default.createElement(_antd.Input,{ref:function ref(ele){return _this.searchInput=ele;},placeholder:\"Search name\",value:_this.state.searchText,onChange:_this.onInputChange,onPressEnter:_this.onSearch}),_react2.default.createElement(_antd.Button,{type:\"primary\",onClick:_this.onSearch},\"Search\"),_react2.default.createElement(_antd.Button,{className:\"btn-secondary ml-1\",onClick:_this.onReset},\"Reset\")),filterIcon:_react2.default.createElement(_antd.Icon,{type:\"filter\",style:{color:_this.state.filtered?'#108ee9':'#aaa'}}),filterDropdownVisible:_this.state.filterDropdownVisible,onFilterDropdownVisibleChange:function onFilterDropdownVisibleChange(visible){_this.setState({filterDropdownVisible:visible},function(){_this.searchInput&&_this.searchInput.focus();});}};var columns=[];var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=column[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var col=_step.value;if(col.sorter&&!col.filterDropdown){var temp={sorter:compare(col.key)};columns.push(_extends({},col,temp));}else if(!col.sorter&&col.filterDropdown){var _temp=_extends({},filter);columns.push(_extends({},col,_temp));}else if(col.sorter&&col.filterDropdown){var _temp2=_extends({sorter:compare(col.key)},filter);columns.push(_extends({},col,_temp2));}else{columns.push(col);}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}return columns;/*\n    const columns = [\n      {\n        title: 'rank',\n        dataIndex: 'rank',\n        key: 'rank',\n        sorter: compare('rank')\n      },\n      {\n        title: 'name',\n        dataIndex: 'name',\n        key: 'name',\n        filterDropdown: (\n            <div className=\"custom-filter-dropdown\">\n              <Input\n                  ref={ele => this.searchInput = ele}\n                  placeholder=\"Search name\"\n                  value={this.state.searchText}\n                  onChange={this.onInputChange}\n                  onPressEnter={this.onSearch}\n              />\n              <Button type=\"primary\" onClick={this.onSearch}>Search</Button>\n            </div>\n        ),\n        filterIcon: <Icon type=\"filter\" style={{color: this.state.filtered ? '#108ee9' : '#aaa'}}/>,\n        filterDropdownVisible: this.state.filterDropdownVisible,\n        onFilterDropdownVisibleChange: (visible) => {\n\n          this.setState({\n            filterDropdownVisible: visible,\n          }, () => {\n            this.searchInput && this.searchInput.focus()\n          });\n        },\n      },\n      {\n        title: 'pair',\n        dataIndex: 'pair',\n        key: 'pair'\n      },\n      {\n        title: 'volumeNative',\n        dataIndex: 'volumeNative',\n        key: 'volumeNative',\n      }\n    ];\n    return columns;\n    */};_this.state={markets:[],filterDropdownVisible:false,data:[],columns:[],searchText:'',filtered:false};return _this;}_createClass(MarketOverview,[{key:\"componentDidMount\",value:function componentDidMount(){}},{key:\"render\",value:function render(){var column=this.props.column;var columns=this.setColumn(column);var tableData=this.props.tableData;var data=this.state.data;if(data.length){tableData=this.state.data;}/*\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n*/// markets = markets.sort(compare(\"rank\")).slice(0, 99);\n//console.log(markets);\nreturn _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(_antd.Table,{columns:columns,dataSource:tableData}));}}]);return MarketOverview;}(_react.Component);exports.default=MarketOverview;\n\n/***/ }),\n\n/***/ 2463:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.RingPieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(714);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(55);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(2193);__webpack_require__(715);__webpack_require__(716);__webpack_require__(2206);__webpack_require__(2209);__webpack_require__(2210);__webpack_require__(2211);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RingPieReact=exports.RingPieReact=function(_React$Component){_inherits(RingPieReact,_React$Component);function RingPieReact(props){_classCallCheck(this,RingPieReact);var _this=_possibleConstructorReturn(this,(RingPieReact.__proto__||Object.getPrototypeOf(RingPieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'ringPie'+id};return _this;}_createClass(RingPieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=[];_chartConfig2.default.ringPieChart.title.text=\"\";function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}if(data&&data.length>0){var sortObj=data.sort(compare(\"name\"));var pairData=[];var exchanges=[];var temp=[];for(var index in sortObj){pairData.push({name:sortObj[index].pair,value:sortObj[index].volume});if(temp.indexOf(sortObj[index].name)<0){temp.push(sortObj[index].name);exchanges.push({name:sortObj[index].name,value:0,subCount:[]});}}for(var _index in exchanges){for(var idx in sortObj){if(sortObj[idx].name===exchanges[_index].name){exchanges[_index].value=exchanges[_index].value+sortObj[idx].volume;exchanges[_index].subCount.push({name:sortObj[idx].pair,value:sortObj[idx].volume});}}}exchanges.sort(compare(\"value\"));var finalExchanges=exchanges.slice(exchanges.length-10,exchanges.length);var finalPairData=[];for(var _index2 in finalExchanges){finalPairData.push.apply(finalPairData,_toConsumableArray(finalExchanges[_index2].subCount));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=temp;_chartConfig2.default.ringPieChart.series[0].data=finalExchanges;_chartConfig2.default.ringPieChart.series[1].data=finalPairData;}if(data&&data.length===0){_chartConfig2.default.ringPieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.ringPieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return RingPieReact;}(_react2.default.Component);exports.default=RingPieReact;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Markets.3a84af72.chunk.js","import React, {Fragment} from \"react\";\nimport {injectIntl} from \"react-intl\";\nimport {connect} from \"react-redux\";\nimport {loadPriceData} from \"../../actions/markets\";\nimport {tu} from \"../../utils/i18n\";\nimport MarketOverview from \"./MarketOverview\";\nimport {TronLoader} from \"../common/loaders\";\nimport {Client} from \"../../services/api\";\nimport LineReact from \"../common/LineChart\";\nimport RingPieReact from \"../common/RingPieChart\";\n\nclass Markets extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      priceGraph: [],\n      volumeGraph: [],\n      markets: [],\n    };\n  }\n\n  componentDidMount() {\n    this.loadMarketData();\n  }\n\n  loadMarketData = async () => {\n    this.props.loadPriceData();\n\n    let markets = await Client.getMarkets();\n\n    this.setState({\n      markets,\n    });\n  };\n\n  formatTableData = (markets) => {\n    let {intl} = this.props;\n    let data = [];\n    markets.sort((a, b) => a.rank - b.rank);\n    if (markets.length) {\n      markets.map((val) => {\n        data.push({\n          key: val.rank,\n          rank: val.rank,\n          name: val.name,\n          pair: val.pair,\n          volumeNative: intl.formatNumber(val.volumeNative)+' TRX',\n          volumePercentage: intl.formatNumber(val.volumePercentage, {\n            maximumFractionDigits: 2,\n            minimumFractionDigits: 2\n          }) + '%',\n          price: '$' + intl.formatNumber(val.price, {maximumFractionDigits: 8})\n        });\n\n      })\n    }\n    return data.slice(0,99);\n  }\n\n\n  customizedColumn = () => {\n    let {intl} = this.props;\n    let column = [\n      {\n        title: intl.formatMessage({id:'rank'}),\n        dataIndex: 'rank',\n        key: 'rank',\n        sorter: true,\n        width: '5%'\n      },\n      {\n        title: intl.formatMessage({id:'exchange'}),\n        dataIndex: 'name',\n        key: 'name',\n        filterDropdown: true\n      },\n      {\n        title: intl.formatMessage({id:'pair'}),\n        dataIndex: 'pair',\n        key: 'pair',\n        width: '12%'\n      },\n      {\n        title: intl.formatMessage({id:'volume'}),\n        dataIndex: 'volumeNative',\n        key: 'volumeNative',\n        width: '14%'\n      },\n      {\n        title: '%',\n        dataIndex: 'volumePercentage',\n        key: 'volumePercentage',\n        width: '8%'\n      },\n      {\n        title: intl.formatMessage({id:'price'}),\n        dataIndex: 'price',\n        key: 'price',\n        width: '10%'\n      }\n    ];\n\n    return column;\n  }\n\n  render() {\n\n    let {intl, priceGraph, volumeGraph} = this.props;\n    let {markets} = this.state;\n    let tableData = this.formatTableData(markets);\n    let column = this.customizedColumn();\n\n    return (\n        <main className=\"container header-overlap pb-3\">\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_price_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      priceGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={priceGraph} keysData={['time', 'close']}\n                                     format={{time: true, date: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_volume_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      volumeGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={volumeGraph} keysData={['time', 'volume']}\n                                     format={{time: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Trade Volume\")}{' Top 10'}</h5>\n                  <RingPieReact style={{height: 700}} data={markets}/>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <MarketOverview tableData={tableData} column={column}/>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {\n    priceGraph: state.markets.price,\n    volumeGraph: state.markets.volume,\n  };\n}\n\nconst mapDispatchToProps = {\n  loadPriceData,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(Markets));\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 2090\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 2091\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 2115\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 2116\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // 拐点图形类型\n    symbol: 'emptyCircle',\n    // 拐点图形大小\n    symbolSize: 4,\n    // 拐点图形旋转控制\n    symbolRotate: null,\n    // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n    showSymbol: true,\n    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    showAllSymbol: false,\n    // 是否连接断点\n    connectNulls: false,\n    // 数据过滤，'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 2127\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 2128\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 2129\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 2130\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 2131\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 2132\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 2133\n// module chunks = 2 3 4","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 2136\n// module chunks = 2 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _model = require(\"../../util/model\");\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 4,\n    show: true,\n    // 布局方式，默认为水平布局，可选为：\n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // 水平对齐\n    // 'auto' | 'left' | 'right'\n    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 图例边框颜色\n    borderColor: '#ccc',\n    borderRadius: 0,\n    // 图例边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 图例内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 各个item之间的间隔，单位px，默认为10，\n    // 横向布局时为水平间隔，纵向布局时为纵向间隔\n    itemGap: 10,\n    // 图例图形宽度\n    itemWidth: 25,\n    // 图例图形高度\n    itemHeight: 14,\n    // 图例关闭时候的颜色\n    inactiveColor: '#ccc',\n    textStyle: {\n      // 图例文字颜色\n      color: '#333'\n    },\n    // formatter: '',\n    // 选择模式，默认开启图例开关\n    selectedMode: true,\n    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n    // selected: null,\n    // 图例内容（详见legend.data，数组中每一项代表一个item\n    // data: [],\n    // Tooltip 相关配置\n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 2137\n// module chunks = 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 2138\n// module chunks = 3 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 2193\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 2194\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 2195\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 2196\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 2197\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 2198\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 2199\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 2200\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 2201\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 2202\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            if((val[keysData[0]]+\"\").length===10)\n              config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n            if((val[keysData[0]]+\"\").length===13)\n              config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]));\n          }\n        }\n        else {\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n        }\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 2206\n// module chunks = 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 2207\n// module chunks = 3 4","function _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 2208\n// module chunks = 3 4","var LegendModel = require(\"./LegendModel\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js\n// module id = 2209\n// module chunks = 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js\n// module id = 2210\n// module chunks = 3 4","var echarts = require(\"../../echarts\");\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js\n// module id = 2211\n// module chunks = 3 4","import React, {Component} from \"react\";\nimport {tu} from \"../../utils/i18n\";\nimport {Client} from \"../../services/api\";\nimport {ExternalLink} from \"../common/Links\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../common/Price\";\nimport {Table, Input, Button, Icon} from 'antd';\n\nexport default class MarketOverview extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      markets: [],\n      filterDropdownVisible: false,\n      data: [],\n      columns: [],\n      searchText: '',\n      filtered: false,\n    }\n  }\n\n  componentDidMount() {\n\n  }\n\n  onInputChange = (e) => {\n    this.setState({searchText: e.target.value});\n  }\n  onReset = () => {\n    this.setState({searchText: ''}, () => {\n      this.onSearch();\n    });\n  }\n  onSearch = () => {\n    let {tableData} = this.props;\n    const {searchText} = this.state;\n    const reg = new RegExp(searchText, 'gi');\n    this.setState({\n      filterDropdownVisible: false,\n      filtered: !!searchText,\n      data: tableData.map((record) => {\n        const match = record.name.match(reg);\n        if (!match) {\n          return null;\n        }\n        return {\n          ...record,\n          name: (\n              <span>\n              {record.name.split(new RegExp(`(?<=${searchText})|(?=${searchText})`, 'i')).map((text, i) => (\n                  text.toLowerCase() === searchText.toLowerCase()\n                      ? <span key={i} className=\"highlight\">{text}</span> : text // eslint-disable-line\n              ))}\n            </span>\n          ),\n        };\n      }).filter(record => !!record),\n    });\n  }\n\n\n  setColumn = (column) => {\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n    let filter = {\n      filterDropdown: (\n          <div className=\"custom-filter-dropdown\">\n            <Input\n                ref={ele => this.searchInput = ele}\n                placeholder=\"Search name\"\n                value={this.state.searchText}\n                onChange={this.onInputChange}\n                onPressEnter={this.onSearch}\n            />\n            <Button type=\"primary\" onClick={this.onSearch}>Search</Button>\n            <Button className=\"btn-secondary ml-1\" onClick={this.onReset}>Reset</Button>\n          </div>\n      ),\n      filterIcon: <Icon type=\"filter\" style={{color: this.state.filtered ? '#108ee9' : '#aaa'}}/>,\n      filterDropdownVisible: this.state.filterDropdownVisible,\n      onFilterDropdownVisibleChange: (visible) => {\n\n        this.setState({\n          filterDropdownVisible: visible,\n        }, () => {\n          this.searchInput && this.searchInput.focus()\n        });\n      }\n    }\n\n    let columns=[];\n\n    for(let col of column){\n      if(col.sorter && !col.filterDropdown) {\n        let temp={sorter: compare(col.key)}\n        columns.push({...col,...temp});\n      }\n      else if(!col.sorter && col.filterDropdown){\n        let temp={...filter}\n        columns.push({...col,...temp});\n      }\n      else if(col.sorter && col.filterDropdown){\n        let temp={sorter: compare(col.key), ...filter}\n        columns.push({...col,...temp});\n      }\n      else{\n        columns.push(col);\n      }\n\n    }\n\n    return columns;\n    /*\n    const columns = [\n      {\n        title: 'rank',\n        dataIndex: 'rank',\n        key: 'rank',\n        sorter: compare('rank')\n      },\n      {\n        title: 'name',\n        dataIndex: 'name',\n        key: 'name',\n        filterDropdown: (\n            <div className=\"custom-filter-dropdown\">\n              <Input\n                  ref={ele => this.searchInput = ele}\n                  placeholder=\"Search name\"\n                  value={this.state.searchText}\n                  onChange={this.onInputChange}\n                  onPressEnter={this.onSearch}\n              />\n              <Button type=\"primary\" onClick={this.onSearch}>Search</Button>\n            </div>\n        ),\n        filterIcon: <Icon type=\"filter\" style={{color: this.state.filtered ? '#108ee9' : '#aaa'}}/>,\n        filterDropdownVisible: this.state.filterDropdownVisible,\n        onFilterDropdownVisibleChange: (visible) => {\n\n          this.setState({\n            filterDropdownVisible: visible,\n          }, () => {\n            this.searchInput && this.searchInput.focus()\n          });\n        },\n      },\n      {\n        title: 'pair',\n        dataIndex: 'pair',\n        key: 'pair'\n      },\n      {\n        title: 'volumeNative',\n        dataIndex: 'volumeNative',\n        key: 'volumeNative',\n      }\n    ];\n    return columns;\n    */\n  }\n\n\n  render() {\n    let column = this.props.column;\n    let columns = this.setColumn(column);\n    let {tableData} = this.props;\n    let {data} = this.state;\n    if(data.length){\n      tableData = this.state.data;\n    }\n/*\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n*/\n   // markets = markets.sort(compare(\"rank\")).slice(0, 99);\n    //console.log(markets);\n\n\n    return (\n\n\n        <div className=\"card\">\n          <Table columns={columns} dataSource={tableData}/>\n          {/*\n            <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th style={{width: 25}}>{tu(\"rank\")}</th>\n                <th>{tu(\"exchange\")}</th>\n                <th className=\"d-none d-sm-table-cell\" style={{width: 75}}>{tu(\"pair\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 100}}>{tu(\"volume\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 75}}>%</th>\n                <th className=\"text-right\" style={{width: 100}}>{tu(\"price\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              markets.map(market => (\n                <tr key={market.rank}>\n                  <th>\n                    {market.rank}\n                  </th>\n                  <td>\n                    <ExternalLink url={market.link}>{market.name}</ExternalLink>\n                  </td>\n                  <td className=\"d-none d-sm-table-cell\" style={{width: 75}}>\n                    <ExternalLink url={market.link}>{market.pair}</ExternalLink>\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={market.volumeNative} />\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={market.volumePercentage} maximumFractionDigits={2} />%\n                  </td>\n                  <td className=\"text-right\">\n                    $<FormattedNumber value={market.price} maximumFractionDigits={8} />\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n          */}\n        </div>\n\n    )\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/MarketOverview.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/legend'\nimport 'echarts/lib/component/legend/ScrollableLegendModel.js'\nimport 'echarts/lib/component/legend/ScrollableLegendView.js'\nimport 'echarts/lib/component/legend/scrollableLegendAction.js'\n\nexport class RingPieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'ringPie' + id\n    }\n  }\n\n  initPie(id) {\n    let {data} = this.props;\n\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.ringPieChart.series[0].data = [];\n    config.ringPieChart.series[1].data = [];\n    config.ringPieChart.legend.data = [];\n    config.ringPieChart.title.text=\"\";\n\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n\n    if (data && data.length > 0) {\n      let sortObj = data.sort(compare(\"name\"));\n      let pairData = [];\n      let exchanges = []\n      let temp = [];\n      for (let index in sortObj) {\n        pairData.push({name: sortObj[index].pair, value: sortObj[index].volume});\n        if (temp.indexOf(sortObj[index].name) < 0) {\n          temp.push(sortObj[index].name)\n          exchanges.push({name: sortObj[index].name, value: 0, subCount: []});\n        }\n      }\n\n      for (let index in exchanges) {\n        for (let idx in sortObj) {\n          if (sortObj[idx].name === exchanges[index].name) {\n            exchanges[index].value = exchanges[index].value + sortObj[idx].volume;\n            exchanges[index].subCount.push({name: sortObj[idx].pair, value: sortObj[idx].volume});\n          }\n        }\n      }\n\n      exchanges.sort(compare(\"value\"));\n      let finalExchanges = exchanges.slice(exchanges.length - 10, exchanges.length);\n      let finalPairData = []\n      for (let index in finalExchanges) {\n        finalPairData.push(...finalExchanges[index].subCount);\n      }\n\n      config.ringPieChart.series[0].data = [];\n      config.ringPieChart.series[1].data = [];\n\n      config.ringPieChart.legend.data = temp;\n\n      config.ringPieChart.series[0].data = finalExchanges;\n      config.ringPieChart.series[1].data = finalPairData;\n\n    }\n    if(data && data.length===0){\n      config.ringPieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.ringPieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default RingPieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/RingPieChart.js"],"sourceRoot":""}