{"version":3,"sources":["../static/js/Stats.c510f026.chunk.js","components/blockchain/Statistics/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/component/toolbox/featureManager.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/component/dataZoom/DataZoomModel.js","../node_modules/echarts/lib/component/dataZoom/DataZoomView.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","../node_modules/echarts/lib/component/dataZoom/helper.js","../node_modules/echarts/lib/component/helper/sliderMove.js","../node_modules/echarts/lib/component/dataZoom/typeDefaulter.js","../node_modules/echarts/lib/component/helper/interactionMutex.js","../node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js","../node_modules/echarts/lib/component/dataZoom/dataZoomAction.js","../node_modules/echarts/lib/component/dataZoom/history.js","utils/tron.js","components/blockchain/Statistics/RichList.js","components/common/PieChart.js","components/common/LineChartTx.js","../node_modules/echarts/lib/component/dataZoom.js","../node_modules/echarts/lib/component/dataZoom/AxisProxy.js","../node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js","../node_modules/echarts/lib/component/dataZoom/SliderZoomView.js","../node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js","../node_modules/echarts/lib/component/dataZoom/InsideZoomView.js","../node_modules/echarts/lib/component/dataZoom/roams.js","../node_modules/echarts/lib/component/helper/RoamController.js","../node_modules/echarts/lib/component/toolbox.js","../node_modules/echarts/lib/component/toolbox/ToolboxModel.js","../node_modules/echarts/lib/component/toolbox/ToolboxView.js","../node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js","../node_modules/echarts/lib/component/toolbox/feature/MagicType.js","../node_modules/echarts/lib/component/toolbox/feature/DataView.js","../node_modules/echarts/lib/component/toolbox/feature/DataZoom.js","../node_modules/echarts/lib/component/helper/BrushController.js","../node_modules/echarts/lib/component/helper/BrushTargetManager.js","../node_modules/echarts/lib/component/helper/brushHelper.js","../node_modules/echarts/lib/component/helper/cursorHelper.js","../node_modules/echarts/lib/component/dataZoomSelect.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomView.js","../node_modules/echarts/lib/component/toolbox/feature/Restore.js","../node_modules/echarts/lib/component/markPoint.js","../node_modules/echarts/lib/component/marker/MarkPointModel.js","../node_modules/echarts/lib/component/marker/MarkerModel.js","../node_modules/echarts/lib/component/marker/MarkPointView.js","../node_modules/echarts/lib/component/marker/markerHelper.js","../node_modules/echarts/lib/component/marker/MarkerView.js"],"names":["webpackJsonp","2040","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_i18n","_api","_constants","_reactRedux","_reactIntl","_lodash","_tron","_RichList","_loaders","_PieChart","_PieChart2","_LineChart","_LineChart2","_LineChartTx","_LineChartTx2","Statistics","_React$Component","_this","getPrototypeOf","accounts","transactionStats","blockStats","transactionValueStats","txOverviewStats","loadAccounts","loadStats","loadTxOverviewStats","_ref","mark","_callee","_ref2","wrap","_context","prev","next","Client","getAccounts","limit","sort","sent","setState","filter","account","includes","tronAddresses","address","slice","map","name","balance","ONE_TRX","stop","_ref3","_callee2","intl","_ref4","stats","_ref5","transactionTotalStats","valueStats","_context2","getTransferStats","groupby","interval","getBlockStats","total","row","timestamp","_ref6","_callee3","_ref7","temp","txs","tx","_context3","getTxOverviewStats","parseInt","push","date","totalTransaction","avgBlockTime","avgBlockSize","totalBlockCount","newAddressSeen","_state","createElement","className","style","height","TronLoader","data","tu","keysData","format","Component","mapDispatchToProps","connect","injectIntl","2090","getSymbolSize","idx","symbolSize","getItemVisual","Array","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","dataIndex","inherits","_default","2091","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","2099","register","ctor","features","2115","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","2116","SymbolDraw","symbolCtor","group","_symbolCtor","symbolNeedsDraw","point","isIgnore","clipShape","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","oldData","_data","SymbolCtor","diff","newIdx","getItemLayout","symbolEl","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","position","el","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","2127","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","lineStyle","width","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","2128","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","coordSysClipShape","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","2129","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","2130","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","2131","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","2132","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","2133","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","2134","retrieveRaw","ret","hasOwnProperty","updateRangeUse","dataZoomModel","rawOption","rangePropMode","_rangePropMode","rangeModeInOption","names","index","percentSpecified","valueSpecified","env","helper","AxisProxy","eachAxisDim","DataZoomModel","extendComponentModel","orient","xAxisIndex","yAxisIndex","filterMode","throttle","startValue","endValue","minSpan","maxSpan","minValueSpan","maxValueSpan","rangeMode","parentModel","_dataIntervalByAxis","_dataInfo","_axisProxies","textStyleModel","_autoThrottle","mergeDefaultAndTheme","doInit","mergeOption","newOption","merge","thisOption","canvasSupported","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","axisIndex","axisModel","dependentModels","axisProxy","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","normalizeToArray","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","singleAxis","singleAxisModel","singleAxisIndex","componentIndex","axisIndices","axisModels","eachSeries","_isSeriesHasAllAxesTypeOf","axisId","queryComponents","mainType","id","indexOf","axisType","is","seriesAxisIndex","globalOption","animation","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","indices","callback","context","getAxisProxy","getAxisModel","setRawRange","ignoreUpdateRangeUsg","getPercentRange","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","axisDimName","getDataValueWindow","hostedBy","getRangePropMode","2135","ComponentView","getTargetCoordInfo","save","coordModel","store","coordIndex","item","model","coordSysLists","getComponent","getCoordSysModel","2136","layout","componentModel","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getWidth","getHeight","rect","getLayoutRect","layoutBox","positionElement","makeBackground","formatUtil","normalizeCssArray","_layout","box","2193","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","curry","2194","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","legendDataProvider","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","superCall","targetList","selected","valueList","percent","$vars","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","show","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","borderWidth","animationType","mixin","2195","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","2196","_targetList","_selectTargetMap","reduce","targetMap","set","createHashMap","select","unSelect","toggleSelected","isSelected","2197","updateDataSelected","uid","dispatchAction","from","seriesId","toggleItemSelected","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","Text","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","textAlign","textVerticalAlign","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","eachChild","child","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","2198","actionInfos","actionInfo","registerAction","eachComponent","subType","query","2199","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","2200","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","2201","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","getBoundingRect","2202","legendModels","findComponents","filterSelf","2203","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","replace","lineId","_props","myChart","getInstanceByDom","document","getElementById","lineChart","title","xAxis","series","val","formatDate","formatTime","setOption","initLine","pure","2204","isCoordSupported","coordType","COORDS","createNameEach","attrs","capitalNames","capitalFirst","capitalAttrs","nameObj","capital","createLinkedNodesFinder","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","node","nodes","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","AXIS_DIMS","2205","handleEnds","handleIndex","restrict","extentSpan","originalDistSign","getSpanSign","extentMinSpan","realExtent","sign","currDistSign","span","2275","registerSubTypeDefaulter","2276","take","zr","resourceKey","userKey","getStore","release","isTaken","ATTR","2277","seriesModelMap","getTargetSeriesModels","isOverallFilter","overallReset","filterData","percentRange","valueRange","2278","linkedNodesFinder","effectedModels","2279","newSnapshot","giveStore","batchItem","dataZoomId","pop","head","snapshot","clear","2429","2430","_Price","RichList","_Component","richList","totals","coins","load","getRichList","FormattedNumber","to","maximumFractionDigits","minimumFractionDigits","TRXPrice","amount","currency","2431","PieReact","pieId","pieChart","initPie","2432","LineReactTx","_extends","assign","txOverviewChart","formatMessage","yAxis","tooltip","formatter","datas","Date","toLocaleString","split","2433","2434","calculateDataExtent","axisDim","seriesModels","dataExtent","seriesData","seriesExtent","getApproximateExtent","fixExtentByAxis","getMin","isCategoryAxis","axisDataLen","getCategories","getMax","setAxisModel","isRestore","percentWindow","_percentWindow","valueWindow","_valueWindow","precision","numberUtil","getPixelPrecision","useOrigin","setRange","toFixed","setMinMaxSpan","minMaxSpan","_minMaxSpan","_dataZoomModel","minMax","valueSpan","parse","_dataExtent","asc","_dimName","_axisIndex","getOtherAxisModel","otherAxisDim","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","getMinMaxSpan","clone","calculateDataWindow","percentExtent","prop","boundValue","boundPercent","targetSeries","dataWindow","restore","isInWindow","dataDims","leftOut","rightOut","hasValue","thisHasValue","thisLeftOut","thisRightOut","range","selectRange","setApproximateExtent","2435","SliderZoomModel","layoutMode","right","top","left","bottom","backgroundColor","dataBackground","areaStyle","borderColor","fillerColor","handleIcon","handleSize","handleStyle","labelPrecision","labelFormatter","showDetail","showDataShadow","zoomLock","textStyle","2436","getOtherDim","thisDim","getCursor","eventTool","DataZoomView","sliderMove","HORIZONTAL","LABEL_GAP","SHOW_DATA_SHADOW_SERIES_TYPE","SliderZoomView","_displayables","_orient","_range","_handleEnds","_size","_handleWidth","_handleHeight","_location","_dragging","_dataShadowInfo","createOrUpdate","_buildView","_updateView","thisGroup","_resetLocation","_resetInterval","barGroup","_renderBackground","_renderHandle","_renderDataShadow","_positionGroup","coordRect","_findCoordRect","ecSize","positionInfo","layoutParams","getLayoutParams","layoutRect","location","targetAxisModel","otherAxisInverse","_getViewExtent","onclick","_onClickPanelClick","_prepareDataShadowInfo","otherDim","getShadowDim","otherDataExtent","otherOffset","lastIsEmpty","otherShadowExtent","thisShadowExtent","areaPoints","thisCoord","stride","otherCoord","thisAxis","displaybles","handles","handleLabels","filler","_onDragMove","onmousemove","e","ondragstart","_showDataInfo","ondragend","_onDragEnd","onmouseover","onmouseout","textPosition","subPixelOptimizeRect","path","createIcon","bRect","handleColor","invisible","textFill","getTextColor","textFont","viewExtent","_updateInterval","viewExtend","nonRealtime","handleInterval","handle","handleHeight","_updateDataInfo","setLabel","barTransform","getTransform","direction","transformDirection","textPoint","applyTransform","orderedHandleEnds","labelTexts","dataInterval","_formatLabel","valueStr","getLabel","isFunction","isString","showOrHide","getLocalTransform","vertex","_dispatchZoomAction","localPoint","transformCoordToLocal","offsetX","offsetY","coordInfoList","getRect","2437","disabled","zoomOnMouseWheel","moveOnMouseMove","preventDefaultMouseMove","2438","roams","InsideZoomView","shouldRecordRange","coordSysName","allCoordIds","coordInfo","generateCoordId","dataZoomOption","coordId","containsPoint","throttleRate","panGetRange","_onPan","zoomGetRange","_onZoom","roamControllerOpt","unregister","controller","oldX","oldY","newX","newY","directionInfo","getDirectionInfo","percentDelta","signal","pixel","pixelLength","mouseX","mouseY","percentPoint","pixelStart","grid","oldPoint","newPoint","pointToCoord","2439","dataZoomInfo","theDataZoomId","theCoordId","record","dataZoomInfos","cleanStore","createController","controllerParams","mergeControllerParams","enable","controlType","setPointerChecker","throttleUtil","batch","getZr","newRecord","RoamController","onPan","onZoom","wrapAndDispatch","getRange","typePriority","type_true","type_move","type_false","type_undefined","oneType","2440","pointerChecker","_zr","_opt","mousedownHandler","mousedown","mousemoveHandler","mousemove","mouseupHandler","mouseup","mousewheelHandler","mousewheel","pinchHandler","pinch","Eventful","disable","isDragging","isPinching","_pinching","notLeftMouse","_x","_y","checkKeyBinding","gestureEvent","interactionMutex","wheelDelta","zoomDelta","zoom","pinchScale","pinchX","pinchY","zoomX","zoomY","roamController","setting","2441","2442","featureManager","ToolboxModel","ignoreSize","feature","featureOpt","featureName","Feature","borderRadius","itemSize","itemGap","showTitle","iconStyle","2443","isUserFeatureName","Model","DataDiffer","listComponentHelper","extendComponentView","toolboxModel","processFeature","newIndex","oldIndex","featureNames","oldName","featureOpts","featureModel","unusable","createIconPaths","setIconStatus","iconName","iconPaths","iconStatus","iconStyleModel","iconStyleEmphasisModel","icons","getIcons","titles","icon","iconStr","__title","_features","_featureNames","titleText","makeFont","needPutOnTop","topOffset","updateView","2444","SaveAsImage","lang","saveAsImageLang","toolbox","saveAsImage","excludeComponents","pixelRatio","$a","download","url","getConnectedDataURL","href","MouseEvent","browser","ie","edge","window","navigator","msSaveOrOpenBlob","bstr","atob","n","u8arr","Uint8Array","charCodeAt","blob","Blob","html","tab","open","write","evt","view","bubbles","cancelable","dispatchEvent","2445","MagicType","magicTypeLang","magicType","line","bar","stack","tiled","seriesIndex","proto","availableIcons","seriesOptGenreator","markPoint","markLine","radioTypes","generateNewSeriesTypes","newSeriesOpt","boundaryGap","radio","currentType","2446","groupSeries","seriesGroupByCategoryAxis","otherSeries","meta","eachRawSeries","other","assembleSeriesWithCategoryAxis","tables","headers","concat","columns","lines","join","ITEM_SPLITER","items","BLOCK_SPLITER","assembleOtherSeries","vals","argLen","getContentFromModel","str","trim","isTSVFormat","block","parseTSVContents","tsv","tsvLines","shift","itemSplitRegex","categories","header","parseListContents","seriesName","hasName","parseContents","blockMetaList","blocks","RegExp","blockMeta","axisKey","DataView","_dom","tryMergeDataOption","originalData","newVal","original","dataViewLang","dataView","readOnly","optionToContent","contentToOption","textColor","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","close","container","removeChild","root","getDom","cssText","innerHTML","viewMain","textarea","htmlOrDom","getOption","isDom","appendChild","buttonContainer","buttonStyle","closeButton","refreshButton","addEventListener","Error","keyCode","which","selectionStart","selectionEnd","substring","clientHeight","newSeriesOptList","seriesOpt","getSeriesByName","2447","DataZoom","_brushController","BrushController","_onBrush","mount","_isZoomActive","retrieveAxisSetting","updateBackBtnStatus","history","updateZoomBtnStatus","zoomActive","dataZoomSelectActive","brushTargetManager","BrushTargetManager","include","setPanels","makePanelOpts","targetInfo","xAxisDeclared","yAxisDeclared","enableBrush","brushType","brushStyle","dataZoomLang","dataZoom","DATA_ZOOM_ID_BASE","back","handlers","unmount","nextActive","areas","setBatch","findDataZoom","found","dzModel","isEnd","updateCovers","matchOutputRanges","area","coordRange","lineX","lineY","registerPreprocessor","addForAxis","axisName","dataZoomOpt","axisIndicesName","givenAxisIndices","forEachComponent","axisOpt","newOpt","$fromToolbox","dataZoomOpts","opts","toolboxOpt","2448","_brushType","_brushOption","_panels","_track","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","baseUID","_handlers","mouseHandlers","handler","eventName","doEnableBrush","brushOption","MUTEX_RESOURCE_KEY","DEFAULT_BRUSH_OPT","doDisableBrush","createCover","cover","coverRenderers","__brushOption","updateZ","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","COVER_Z","updateCoverAfterCreation","updateCommon","getPanelByPoint","localCursorPoint","panels","panel","transform","_transform","pn","isTargetByCursor","getPanelByCover","panelId","clearCovers","covers","originalLength","removeOnClick","shouldShowCover","track","mathPow","UNSELECT_THRESHOLD","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","makeStyle","updateBaseRect","localRange","mathMax","MIN_RESIZE_LINE_WIDTH","xa","ya","x2a","y2a","widtha","heighta","updateRectShape","transformable","mainEl","childOfName","globalDir","getGlobalDirection","CURSOR_MAP","w","h","pointsToRect","clipByPanel","formatRectRange","mathMin","localDirection","s","inverseMap","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","DIRECTION_MAP","driftPolygon","localD","localZero","xmin","ymin","resetCursor","currPanel","setCursorStyle","preventDefault","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","brushMode","determineBrushType","getCreatingRange","defaultBrushType","handleDragEnd","getLineRenderer","xyIndex","localTrack","ends","otherExtent","getLinearBrushOtherExtent","pow","ne","sw","nw","se","panelOpts","enableGlobalPan","eachCover","brushOptionList","getKey","tmpIdPrefix","oldGetKey","addOrUpdate","newBrushOption","oldCovers","newCovers","2449","targetInfoList","_targetInfoList","foundCpts","parseFinder","targetInfoBuilders","builder","formatMinMax","includeMainTypes","INCLUDE_FINDER_MAIN_TYPES","axisConvert","axisNameIndex","rangeOrCoordRange","values","coordToData","toLocalCoord","xyMinMax","axisDiffProcessor","refer","scales","getScales","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","brushHelper","COORD_CONVERTS","setOutputRanges","coordRanges","coordConvert","__rangeOffset","diffProcessor","findTargetInfo","coordSyses","setInputRanges","rangeOffset","getDefaultBrushType","getPanelRect","makeRectPanelClipPath","makeRectIsTargetByCursor","coordSysModel","makeLinearBrushOtherExtent","controlSeries","areaPanelId","targetInfoMatchers","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","gridModel","cartesians","getCartesians","panelRectBuilder","geo","geoModels","geoModel","xAxisModel","yAxisModel","xminymin","xmaxymax","2450","normalizeRect","localPoints","graphicUtil","clipPointsByRect","specifiedXYIndex","brushWidth","base","targetModel","onIrrelevantElement","BoundingRect","_cursorHelper","2451","targetCoordSysModel","getComponentByElement","topTarget","IRRELEVANT_EXCLUDES","axisPointer","2452","2453","2454","2455","Restore","restoreLang","resetOption","2456","2457","MarkerModel","2458","fillLabel","dataFormatMixin","addCommas","encodeHTML","extraOpt","createdBySelf","hostSeries","__hostSeries","modelPropName","markerOpt","markerModel","formatTooltip","formattedValue","2459","updateMarkerLayout","mpData","xPx","yPx","getMarkerPosition","getValues","createList","mpModel","coordDimsInfos","dataOpt","markerHelper","dataTransform","dimValueGetter","MarkerView","updateTransform","markPointModel","markerGroupMap","renderSeries","symbolDrawMap","dataModel","__keep","2460","hasXOrY","parseFloat","hasXAndY","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","calcDataDim","numCalculate","indicesOfNearest","getPrecision","axisInfo","getAxisInfo","markerTypeCalculator","baseDataDim","valueDataDim","valueIndex","getDimension","dataDimToCoordDim","dataDim","dimItem","containData","2461","markerModelKey"],"mappings":"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","file":"static/js/Stats.c510f026.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 2040:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(14);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(13);var _api=__webpack_require__(15);var _constants=__webpack_require__(31);var _reactRedux=__webpack_require__(16);var _reactIntl=__webpack_require__(17);var _lodash=__webpack_require__(26);var _tron=__webpack_require__(2429);var _RichList=__webpack_require__(2430);var _RichList2=_interopRequireDefault(_RichList);var _loaders=__webpack_require__(38);var _PieChart=__webpack_require__(2431);var _PieChart2=_interopRequireDefault(_PieChart);var _LineChart=__webpack_require__(2203);var _LineChart2=_interopRequireDefault(_LineChart);var _LineChartTx=__webpack_require__(2432);var _LineChartTx2=_interopRequireDefault(_LineChartTx);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Statistics=function(_React$Component){_inherits(Statistics,_React$Component);function Statistics(){_classCallCheck(this,Statistics);var _this=_possibleConstructorReturn(this,(Statistics.__proto__||Object.getPrototypeOf(Statistics)).call(this));_this.state={accounts:null,transactionStats:null,blockStats:null,transactionValueStats:null,txOverviewStats:null};return _this;}_createClass(Statistics,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadAccounts();this.loadStats();this.loadTxOverviewStats();}},{key:\"loadAccounts\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,accounts;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getAccounts({limit:35,sort:'-balance'});case 2:_ref2=_context.sent;accounts=_ref2.accounts;this.setState({accounts:(0,_lodash.filter)(accounts,function(account){return!(0,_lodash.includes)(_tron.tronAddresses,account.address);}).slice(0,10).map(function(account){return{name:account.address,value:account.balance/_constants.ONE_TRX};})});case 5:case\"end\":return _context.stop();}}},_callee,this);}));function loadAccounts(){return _ref.apply(this,arguments);}return loadAccounts;}()},{key:\"loadStats\",value:function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee2(){var intl,_ref4,stats,_ref5,blockStats,transactionTotalStats,valueStats;return _regenerator2.default.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:intl=this.props.intl;_context2.next=3;return _api.Client.getTransferStats({groupby:'timestamp',interval:'hour'});case 3:_ref4=_context2.sent;stats=_ref4.stats;_context2.next=7;return _api.Client.getBlockStats({info:\"avg-block-size\"});case 7:_ref5=_context2.sent;blockStats=_ref5.stats;transactionTotalStats=stats.total.map(function(row){return{timestamp:row.timestamp,value:row.value};});valueStats=stats.value.map(function(row){return{timestamp:row.timestamp,value:row.value/_constants.ONE_TRX};});blockStats=blockStats.map(function(row){return{timestamp:row.timestamp,value:row.value};});this.setState({transactionStats:transactionTotalStats,transactionValueStats:valueStats,blockStats:blockStats});case 13:case\"end\":return _context2.stop();}}},_callee2,this);}));function loadStats(){return _ref3.apply(this,arguments);}return loadStats;}()},{key:\"loadTxOverviewStats\",value:function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee3(){var _ref7,txOverviewStats,temp,txs,tx;return _regenerator2.default.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return _api.Client.getTxOverviewStats();case 2:_ref7=_context3.sent;txOverviewStats=_ref7.txOverviewStats;temp=[];for(txs in txOverviewStats){tx=parseInt(txs);if(tx===0)temp.push(txOverviewStats[tx]);else temp.push({date:txOverviewStats[tx].date,totalTransaction:txOverviewStats[tx].totalTransaction-txOverviewStats[tx-1].totalTransaction,avgBlockTime:txOverviewStats[tx].avgBlockTime,avgBlockSize:txOverviewStats[tx].avgBlockSize,totalBlockCount:txOverviewStats[tx].totalBlockCount-txOverviewStats[tx-1].totalBlockCount,newAddressSeen:txOverviewStats[tx].newAddressSeen});}this.setState({txOverviewStats:temp});case 7:case\"end\":return _context3.stop();}}},_callee3,this);}));function loadTxOverviewStats(){return _ref6.apply(this,arguments);}return loadTxOverviewStats;}()},{key:\"render\",value:function render(){var _state=this.state,txOverviewStats=_state.txOverviewStats,transactionStats=_state.transactionStats,transactionValueStats=_state.transactionValueStats,blockStats=_state.blockStats,accounts=_state.accounts;return _react2.default.createElement(\"main\",{className:\"container header-overlap\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-12 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"div\",{style:{height:350}},txOverviewStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChartTx2.default,{style:{height:350},data:txOverviewStats})))))),_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Top\"),\" \",accounts!==null?accounts.length:0,\" \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"div\",{style:{height:300}},accounts===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_PieChart2.default,{style:{height:300},data:accounts}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"trx_transferred_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionValueStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionValueStats,keysData:['timestamp','value'],format:{timestamp:true}})))))),_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"transactions_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionStats,keysData:['timestamp','value'],format:{timestamp:true}}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"average_blocksize\"),\" (\",(0,_i18n.tu)(\"bytes\"),\")\"),_react2.default.createElement(\"div\",{style:{height:300}},blockStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:blockStats,keysData:['timestamp','value'],format:{timestamp:true}})))))));}}]);return Statistics;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps)((0,_reactIntl.injectIntl)(Statistics));\n\n/***/ }),\n\n/***/ 2090:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar _symbol = __webpack_require__(376);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(41);\n\nvar _number = __webpack_require__(50);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(728);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2091:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(241);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(9);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 2099:\n/***/ (function(module, exports) {\n\nvar features = {};\n\nfunction register(name, ctor) {\n  features[name] = ctor;\n}\n\nfunction get(name) {\n  return features[name];\n}\n\nexports.register = register;\nexports.get = get;\n\n/***/ }),\n\n/***/ 2115:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\n__webpack_require__(2127);\n\n__webpack_require__(2128);\n\nvar visualSymbol = __webpack_require__(2131);\n\nvar layoutPoints = __webpack_require__(2132);\n\nvar dataSample = __webpack_require__(2133);\n\n__webpack_require__(729);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 2116:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(41);\n\nvar SymbolClz = __webpack_require__(2090);\n\nvar _util = __webpack_require__(9);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2127:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(378);\n\nvar SeriesModel = __webpack_require__(377);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // 拐点图形类型\n    symbol: 'emptyCircle',\n    // 拐点图形大小\n    symbolSize: 4,\n    // 拐点图形旋转控制\n    symbolRotate: null,\n    // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n    showSymbol: true,\n    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    showAllSymbol: false,\n    // 是否连接断点\n    connectNulls: false,\n    // 数据过滤，'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2128:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(9);\n\nvar SymbolDraw = __webpack_require__(2116);\n\nvar SymbolClz = __webpack_require__(2090);\n\nvar lineAnimationDiff = __webpack_require__(2129);\n\nvar graphic = __webpack_require__(41);\n\nvar modelUtil = __webpack_require__(28);\n\nvar _poly = __webpack_require__(2130);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(718);\n\nvar _helper = __webpack_require__(2091);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2129:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(2091);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2130:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(57);\n\nvar vec2 = __webpack_require__(45);\n\nvar fixClipWithShadow = __webpack_require__(726);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 2131:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2132:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(9);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(727);\n\nvar _dataStackHelper = __webpack_require__(241);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2133:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2134:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar env = __webpack_require__(51);\n\nvar modelUtil = __webpack_require__(28);\n\nvar helper = __webpack_require__(2204);\n\nvar AxisProxy = __webpack_require__(2434);\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n    // 例如series.type === scatter时。\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2135:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ComponentView = __webpack_require__(743);\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2136:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(98);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(70);\n\nvar graphic = __webpack_require__(41);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 2193:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\n__webpack_require__(2194);\n\n__webpack_require__(2197);\n\nvar createDataSelectAction = __webpack_require__(2198);\n\nvar dataColor = __webpack_require__(2199);\n\nvar pieLayout = __webpack_require__(2200);\n\nvar dataFilter = __webpack_require__(2202);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 2194:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar createListSimply = __webpack_require__(2195);\n\nvar zrUtil = __webpack_require__(9);\n\nvar modelUtil = __webpack_require__(28);\n\nvar _number = __webpack_require__(50);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(2196);\n\nvar _dataProvider = __webpack_require__(152);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2195:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(380);\n\nvar List = __webpack_require__(379);\n\nvar _util = __webpack_require__(9);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2196:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2197:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(41);\n\nvar ChartView = __webpack_require__(718);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2198:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2199:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(9);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2200:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(50);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(2201);\n\nvar zrUtil = __webpack_require__(9);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2201:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(123);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2202:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2203:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(17);var _chartConfig=__webpack_require__(714);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(55);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(2115);__webpack_require__(715);__webpack_require__(716);var _reactRedux=__webpack_require__(16);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{if((val[keysData[0]]+\"\").length===10)_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));if((val[keysData[0]]+\"\").length===13)_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]));}}else{_chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);}_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 2204:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar formatUtil = __webpack_require__(70);\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n/***/ }),\n\n/***/ 2205:\n/***/ (function(module, exports) {\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2275:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(100);\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n/***/ }),\n\n/***/ 2276:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;\n\n/***/ }),\n\n/***/ 2277:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar _util = __webpack_require__(9);\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\necharts.registerProcessor({\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);\n        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n          seriesModelMap.set(seriesModel.uid, seriesModel);\n        });\n      });\n    });\n    return seriesModelMap;\n  },\n  isOverallFilter: true,\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      var percentRange = axisProxy.getDataPercentWindow();\n      var valueRange = axisProxy.getDataValueWindow();\n      dataZoomModel.setRawRange({\n        start: percentRange[0],\n        end: percentRange[1],\n        startValue: valueRange[0],\n        endValue: valueRange[1]\n      }, true);\n    });\n  }\n});\n\n/***/ }),\n\n/***/ 2278:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar helper = __webpack_require__(2204);\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n/***/ }),\n\n/***/ 2279:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar each = zrUtil.each;\nvar ATTR = '\\0_ec_hist_store';\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\n\nfunction push(ecModel, newSnapshot) {\n  var store = giveStore(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = store.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = store[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        store[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  store.push(newSnapshot);\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\n\n\nfunction pop(ecModel) {\n  var store = giveStore(ecModel);\n  var head = store[store.length - 1];\n  store.length > 1 && store.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = store.length - 1; i >= 0; i--) {\n      var batchItem = store[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction clear(ecModel) {\n  ecModel[ATTR] = null;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\n\n\nfunction count(ecModel) {\n  return giveStore(ecModel).length;\n}\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(ecModel) {\n  var store = ecModel[ATTR];\n\n  if (!store) {\n    store = ecModel[ATTR] = [{}];\n  }\n\n  return store;\n}\n\nexports.push = push;\nexports.pop = pop;\nexports.clear = clear;\nexports.count = count;\n\n/***/ }),\n\n/***/ 2429:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var tronAddresses=exports.tronAddresses=['27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS','27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj','27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx','27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3'];\n\n/***/ }),\n\n/***/ 2430:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(14);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _api=__webpack_require__(15);var _reactIntl=__webpack_require__(17);var _Price=__webpack_require__(71);var _i18n=__webpack_require__(13);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RichList=function(_Component){_inherits(RichList,_Component);function RichList(){_classCallCheck(this,RichList);var _this=_possibleConstructorReturn(this,(RichList.__proto__||Object.getPrototypeOf(RichList)).call(this));_this.state={richList:[],totals:{accounts:0,coins:0}};return _this;}_createClass(RichList,[{key:\"componentDidMount\",value:function componentDidMount(){this.load();}},{key:\"load\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,data,total;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getRichList();case 2:_ref2=_context.sent;data=_ref2.data;total=_ref2.total;this.setState({richList:data,totals:total});case 6:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _ref.apply(this,arguments);}return load;}()},{key:\"render\",value:function render(){var _state=this.state,richList=_state.richList,totals=_state.totals;return _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"rich_list\"))),_react2.default.createElement(\"table\",{className:\"table table-hover bg-white m-0 table-striped\"},_react2.default.createElement(\"thead\",{className:\"thead-dark\"},_react2.default.createElement(\"tr\",null,_react2.default.createElement(\"th\",null,(0,_i18n.tu)(\"balance\")),_react2.default.createElement(\"th\",{className:\"d-none d-lg-table-cell\"},(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-nowrap text-right\"},\"% \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-right d-none d-md-table-cell\"},(0,_i18n.tu)(\"TRX\")),_react2.default.createElement(\"th\",{className:\"text-right\"},\"$ \",(0,_i18n.tu)(\"USD\")),_react2.default.createElement(\"th\",{className:\"text-right  d-none d-md-table-cell\"},\"% \",(0,_i18n.tu)(\"Coins\")))),_react2.default.createElement(\"tbody\",null,richList.map(function(row,index){return _react2.default.createElement(\"tr\",{key:index},_react2.default.createElement(\"th\",null,_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.from}),' - ',_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.to})),_react2.default.createElement(\"td\",{className:\"d-none d-lg-table-cell\"},row.accounts),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\",style:{width:100}},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.accounts/totals.accounts*100,maximumFractionDigits:2,minimumFractionDigits:2}),\" %\"),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance,currency:\"USD\"})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.balance/totals.coins*100,maximumFractionDigits:4,minimumFractionDigits:4}),\" %\"));}))));}}]);return RichList;}(_react.Component);exports.default=RichList;\n\n/***/ }),\n\n/***/ 2431:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.PieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(714);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(55);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(2193);__webpack_require__(715);__webpack_require__(716);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var PieReact=exports.PieReact=function(_React$Component){_inherits(PieReact,_React$Component);function PieReact(props){_classCallCheck(this,PieReact);var _this=_possibleConstructorReturn(this,(PieReact.__proto__||Object.getPrototypeOf(PieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'pie'+id};return _this;}_createClass(PieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.pieChart.series[0].data=[];_chartConfig2.default.pieChart.title.text=\"\";if(data&&data.length>0){_chartConfig2.default.pieChart.series[0].data=data;}if(data&&data.length===0){_chartConfig2.default.pieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.pieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return PieReact;}(_react2.default.Component);exports.default=PieReact;\n\n/***/ }),\n\n/***/ 2432:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReactTx=undefined;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(17);var _chartConfig=__webpack_require__(714);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(55);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(2115);__webpack_require__(715);__webpack_require__(716);__webpack_require__(2433);__webpack_require__(2441);__webpack_require__(2456);var _reactRedux=__webpack_require__(16);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReactTx=exports.LineReactTx=function(_React$Component){_inherits(LineReactTx,_React$Component);function LineReactTx(props){_classCallCheck(this,LineReactTx);var _this=_possibleConstructorReturn(this,(LineReactTx.__proto__||Object.getPrototypeOf(LineReactTx)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'lineTx'+id};return _this;}_createClass(LineReactTx,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,data=_props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.txOverviewChart.title.text=intl.formatMessage({id:'TRX_transaction_chart'});_chartConfig2.default.txOverviewChart.xAxis[0].data=[];_chartConfig2.default.txOverviewChart.series[0].data=[];_chartConfig2.default.txOverviewChart.yAxis[0].name=intl.formatMessage({id:'transactions_per_day'});_chartConfig2.default.txOverviewChart.tooltip.formatter=function(datas){var date=new Date(parseInt(datas[0].data.date)).toLocaleString().split(' ')[0];return intl.formatMessage({id:'date'})+' : '+date+'<br/>'+intl.formatMessage({id:'total_transactions'})+' : '+datas[0].data.totalTransaction+'<br/>'+intl.formatMessage({id:'avg_blockTime'})+' : '+datas[0].data.avgBlockTime+'<br/>'+intl.formatMessage({id:'avg_blockSize'})+' : '+datas[0].data.avgBlockSize+'<br/>'+intl.formatMessage({id:'total_BlockCount'})+' : '+datas[0].data.totalBlockCount+'<br/>'+intl.formatMessage({id:'new_address_seen'})+' : '+datas[0].data.newAddressSeen+'<br/>';};if(data&&data.length>0){data.map(function(val){var temp=void 0;temp=_extends({},val,{value:val.totalTransaction});_chartConfig2.default.txOverviewChart.xAxis[0].data.push(intl.formatDate(val.date));_chartConfig2.default.txOverviewChart.series[0].data.push(temp);});}if(data&&data.length===0){_chartConfig2.default.txOverviewChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.txOverviewChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReactTx;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReactTx));\n\n/***/ }),\n\n/***/ 2433:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(2275);\n\n__webpack_require__(2134);\n\n__webpack_require__(2135);\n\n__webpack_require__(2435);\n\n__webpack_require__(2436);\n\n__webpack_require__(2437);\n\n__webpack_require__(2438);\n\n__webpack_require__(2277);\n\n__webpack_require__(2278);\n\n/***/ }),\n\n/***/ 2434:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar numberUtil = __webpack_require__(50);\n\nvar helper = __webpack_require__(2204);\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n    // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2435:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(2134);\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2436:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar eventTool = __webpack_require__(149);\n\nvar graphic = __webpack_require__(41);\n\nvar throttle = __webpack_require__(245);\n\nvar DataZoomView = __webpack_require__(2135);\n\nvar numberUtil = __webpack_require__(50);\n\nvar layout = __webpack_require__(98);\n\nvar sliderMove = __webpack_require__(2205);\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // 应该使用统一的空判断？还是在list里进行空判断？\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    realtime && this._dispatchZoomAction();\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2437:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(2134);\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2438:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar DataZoomView = __webpack_require__(2135);\n\nvar sliderMove = __webpack_require__(2205);\n\nvar roams = __webpack_require__(2439);\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2439:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar RoamController = __webpack_require__(2440);\n\nvar throttleUtil = __webpack_require__(245);\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {}; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n/***/ }),\n\n/***/ 2440:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar Eventful = __webpack_require__(151);\n\nvar eventTool = __webpack_require__(149);\n\nvar interactionMutex = __webpack_require__(2276);\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n  /**\n   * @type {Function}\n   */\n  this.pointerChecker;\n  /**\n   * @type {module:zrender}\n   */\n\n  this._zr = zr;\n  /**\n   * @type {Object}\n   */\n\n  this._opt = {}; // Avoid two roamController bind the same handler\n\n  var bind = zrUtil.bind;\n  var mousedownHandler = bind(mousedown, this);\n  var mousemoveHandler = bind(mousemove, this);\n  var mouseupHandler = bind(mouseup, this);\n  var mousewheelHandler = bind(mousewheel, this);\n  var pinchHandler = bind(pinch, this);\n  Eventful.call(this);\n  /**\n   * @param {Function} pointerChecker\n   *                   input: x, y\n   *                   output: boolean\n   */\n\n  this.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  /**\n   * Notice: only enable needed types. For example, if 'zoom'\n   * is not needed, 'zoom' should not be enabled, otherwise\n   * default mousewheel behaviour (scroll page) will be disabled.\n   *\n   * @param  {boolean|string} [controlType=true] Specify the control type,\n   *                          which can be null/undefined or true/false\n   *                          or 'pan/move' or 'zoom'/'scale'\n   * @param {Object} [opt]\n   * @param {Object} [opt.zoomOnMouseWheel=true]\n   * @param {Object} [opt.moveOnMouseMove=true]\n   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n   */\n\n\n  this.enable = function (controlType, opt) {\n    // Disable previous first\n    this.disable();\n    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      preventDefaultMouseMove: true\n    });\n\n    if (controlType == null) {\n      controlType = true;\n    }\n\n    if (controlType === true || controlType === 'move' || controlType === 'pan') {\n      zr.on('mousedown', mousedownHandler);\n      zr.on('mousemove', mousemoveHandler);\n      zr.on('mouseup', mouseupHandler);\n    }\n\n    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n      zr.on('mousewheel', mousewheelHandler);\n      zr.on('pinch', pinchHandler);\n    }\n  };\n\n  this.disable = function () {\n    zr.off('mousedown', mousedownHandler);\n    zr.off('mousemove', mousemoveHandler);\n    zr.off('mouseup', mouseupHandler);\n    zr.off('mousewheel', mousewheelHandler);\n    zr.off('pinch', pinchHandler);\n  };\n\n  this.dispose = this.disable;\n\n  this.isDragging = function () {\n    return this._dragging;\n  };\n\n  this.isPinching = function () {\n    return this._pinching;\n  };\n}\n\nzrUtil.mixin(RoamController, Eventful);\n\nfunction mousedown(e) {\n  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY; // Only check on mosedown, but not mousemove.\n  // Mouse can be out of target when mouse moving.\n\n  if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n    this._x = x;\n    this._y = y;\n    this._dragging = true;\n  }\n}\n\nfunction mousemove(e) {\n  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY;\n  var oldX = this._x;\n  var oldY = this._y;\n  var dx = x - oldX;\n  var dy = y - oldY;\n  this._x = x;\n  this._y = y;\n  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);\n  this.trigger('pan', dx, dy, oldX, oldY, x, y);\n}\n\nfunction mouseup(e) {\n  if (!eventTool.notLeftMouse(e)) {\n    this._dragging = false;\n  }\n}\n\nfunction mousewheel(e) {\n  // wheelDelta maybe -0 in chrome mac.\n  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {\n    return;\n  } // Convenience:\n  // Mac and VM Windows on Mac: scroll up: zoom out.\n  // Windows: scroll up: zoom in.\n\n\n  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n}\n\nfunction pinch(e) {\n  if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n}\n\nfunction zoom(e, zoomDelta, zoomX, zoomY) {\n  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    eventTool.stop(e.event);\n    this.trigger('zoom', zoomDelta, zoomX, zoomY);\n  }\n}\n\nfunction checkKeyBinding(roamController, prop, e) {\n  var setting = roamController._opt[prop];\n  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);\n}\n\nvar _default = RoamController;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2441:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(2442);\n\n__webpack_require__(2443);\n\n__webpack_require__(2444);\n\n__webpack_require__(2445);\n\n__webpack_require__(2446);\n\n__webpack_require__(2447);\n\n__webpack_require__(2455);\n\n/***/ }),\n\n/***/ 2442:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar featureManager = __webpack_require__(2099);\n\nvar ToolboxModel = echarts.extendComponentModel({\n  type: 'toolbox',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  mergeDefaultAndTheme: function (option) {\n    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n    zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager.get(featureName);\n      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n    });\n  },\n  defaultOption: {\n    show: true,\n    z: 6,\n    zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      } // textStyle: {},\n      // feature\n\n    }\n  }\n});\nvar _default = ToolboxModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2443:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar textContain = __webpack_require__(123);\n\nvar featureManager = __webpack_require__(2099);\n\nvar graphic = __webpack_require__(41);\n\nvar Model = __webpack_require__(79);\n\nvar DataDiffer = __webpack_require__(731);\n\nvar listComponentHelper = __webpack_require__(2136);\n\nvar _default = echarts.extendComponentView({\n  type: 'toolbox',\n  render: function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    zrUtil.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            model: featureModel,\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = featureManager.get(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature(featureModel, ecModel, api);\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n\n        feature.model = featureModel;\n        feature.ecModel = ecModel;\n        feature.api = api;\n      }\n\n      if (!featureName && oldName) {\n        feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || feature.unusable) {\n        feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status; // FIXME\n\n        iconPaths[iconName] && iconPaths[iconName].trigger(status);\n      };\n\n      if (feature.render) {\n        feature.render(featureModel, ecModel, api, payload);\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n\n      if (typeof icons === 'string') {\n        var icon = icons;\n        var title = titles;\n        icons = {};\n        titles = {};\n        icons[featureName] = icon;\n        titles[featureName] = title;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      zrUtil.each(icons, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        });\n        path.setStyle(iconStyleModel.getItemStyle());\n        path.hoverStyle = iconStyleEmphasisModel.getItemStyle();\n        graphic.setHoverStyle(path);\n\n        if (toolboxModel.get('showTitle')) {\n          path.__title = titles[iconName];\n          path.on('mouseover', function () {\n            // Should not reuse above hoverStyle, which might be modified.\n            var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n            path.setStyle({\n              text: titles[iconName],\n              textPosition: hoverStyle.textPosition || 'bottom',\n              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n              textAlign: hoverStyle.textAlign || 'center'\n            });\n          }).on('mouseout', function () {\n            path.setStyle({\n              textFill: null\n            });\n          });\n        }\n\n        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n        group.add(path);\n        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      var hoverStyle = icon.hoverStyle; // May be background element\n\n      if (hoverStyle && titleText) {\n        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));\n        var offsetX = icon.position[0] + group.position[0];\n        var offsetY = icon.position[1] + group.position[1] + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          hoverStyle.textPosition = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          hoverStyle.textPosition = ['100%', topOffset];\n          hoverStyle.textAlign = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          hoverStyle.textPosition = [0, topOffset];\n          hoverStyle.textAlign = 'left';\n        }\n      }\n    });\n  },\n  updateView: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  },\n  // updateLayout: function (toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n  remove: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  },\n  dispose: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.dispose && feature.dispose(ecModel, api);\n    });\n  }\n});\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2444:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar env = __webpack_require__(51);\n\nvar lang = __webpack_require__(719);\n\nvar featureManager = __webpack_require__(2099);\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n  this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n  show: true,\n  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n  title: saveAsImageLang.title,\n  type: 'png',\n  // Default use option.backgroundColor\n  // backgroundColor: '#fff',\n  name: '',\n  excludeComponents: ['toolbox'],\n  pixelRatio: 1,\n  lang: saveAsImageLang.lang.slice()\n};\nSaveAsImage.prototype.unusable = !env.canvasSupported;\nvar proto = SaveAsImage.prototype;\n\nproto.onclick = function (ecModel, api) {\n  var model = this.model;\n  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n  var $a = document.createElement('a');\n  var type = model.get('type', true) || 'png';\n  $a.download = title + '.' + type;\n  $a.target = '_blank';\n  var url = api.getConnectedDataURL({\n    type: type,\n    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n    excludeComponents: model.get('excludeComponents'),\n    pixelRatio: model.get('pixelRatio')\n  });\n  $a.href = url; // Chrome and Firefox\n\n  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: false\n    });\n    $a.dispatchEvent(evt);\n  } // IE\n  else {\n      if (window.navigator.msSaveOrOpenBlob) {\n        var bstr = atob(url.split(',')[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blob = new Blob([u8arr]);\n        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n      }\n    }\n};\n\nfeatureManager.register('saveAsImage', SaveAsImage);\nvar _default = SaveAsImage;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2445:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar lang = __webpack_require__(719);\n\nvar featureManager = __webpack_require__(2099);\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n  this.model = model;\n}\n\nMagicType.defaultOption = {\n  show: true,\n  type: [],\n  // Icon group\n  icon: {\n    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',\n    // jshint ignore:line\n    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n  },\n  // `line`, `bar`, `stack`, `tiled`\n  title: zrUtil.clone(magicTypeLang.title),\n  option: {},\n  seriesIndex: {}\n};\nvar proto = MagicType.prototype;\n\nproto.getIcons = function () {\n  var model = this.model;\n  var availableIcons = model.get('icon');\n  var icons = {};\n  zrUtil.each(model.get('type'), function (type) {\n    if (availableIcons[type]) {\n      icons[type] = availableIcons[type];\n    }\n  });\n  return icons;\n};\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.line') || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.bar') || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: '__ec_magicType_stack__'\n      }, model.get('option.stack') || {}, true);\n    }\n  },\n  'tiled': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: ''\n      }, model.get('option.tiled') || {}, true);\n    }\n  }\n};\nvar radioTypes = [['line', 'bar'], ['stack', 'tiled']];\n\nproto.onclick = function (ecModel, api, type) {\n  var model = this.model;\n  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType\n\n  if (!seriesOptGenreator[type]) {\n    return;\n  }\n\n  var newOption = {\n    series: []\n  };\n\n  var generateNewSeriesTypes = function (seriesModel) {\n    var seriesType = seriesModel.subType;\n    var seriesId = seriesModel.id;\n    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n    if (newSeriesOpt) {\n      // PENDING If merge original option?\n      zrUtil.defaults(newSeriesOpt, seriesModel.option);\n      newOption.series.push(newSeriesOpt);\n    } // Modify boundaryGap\n\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (categoryAxis) {\n        var axisDim = categoryAxis.dim;\n        var axisType = axisDim + 'Axis';\n        var axisModel = ecModel.queryComponents({\n          mainType: axisType,\n          index: seriesModel.get(name + 'Index'),\n          id: seriesModel.get(name + 'Id')\n        })[0];\n        var axisIndex = axisModel.componentIndex;\n        newOption[axisType] = newOption[axisType] || [];\n\n        for (var i = 0; i <= axisIndex; i++) {\n          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n        }\n\n        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n      }\n    }\n  };\n\n  zrUtil.each(radioTypes, function (radio) {\n    if (zrUtil.indexOf(radio, type) >= 0) {\n      zrUtil.each(radio, function (item) {\n        model.setIconStatus(item, 'normal');\n      });\n    }\n  });\n  model.setIconStatus(type, 'emphasis');\n  ecModel.eachComponent({\n    mainType: 'series',\n    query: seriesIndex == null ? null : {\n      seriesIndex: seriesIndex\n    }\n  }, generateNewSeriesTypes);\n  api.dispatchAction({\n    type: 'changeMagicType',\n    currentType: type,\n    newOption: newOption\n  });\n};\n\necharts.registerAction({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\nfeatureManager.register('magicType', MagicType);\nvar _default = MagicType;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2446:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar eventTool = __webpack_require__(149);\n\nvar lang = __webpack_require__(719);\n\nvar featureManager = __webpack_require__(2099);\n\nvar dataViewLang = lang.toolbox.dataView;\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(series) {\n  var tables = [];\n  zrUtil.each(series, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n      return series.name;\n    }));\n    var columns = [categoryAxis.model.getCategories()];\n    zrUtil.each(group.series, function (series) {\n      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleOtherSeries(series) {\n  return zrUtil.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\n\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = zrUtil.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\n\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var items = trim(lines[i]).split(itemSplitRegex);\n    var name = '';\n    var value;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\n\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  zrUtil.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\n\n\nfunction DataView(model) {\n  this._dom = null;\n  this.model = model;\n}\n\nDataView.defaultOption = {\n  show: true,\n  readOnly: false,\n  optionToContent: null,\n  contentToOption: null,\n  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n  title: zrUtil.clone(dataViewLang.title),\n  lang: zrUtil.clone(dataViewLang.lang),\n  backgroundColor: '#fff',\n  textColor: '#000',\n  textareaColor: '#fff',\n  textareaBorderColor: '#333',\n  buttonColor: '#c23531',\n  buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n  var container = api.getDom();\n  var model = this.model;\n\n  if (this._dom) {\n    container.removeChild(this._dom);\n  }\n\n  var root = document.createElement('div');\n  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n  var header = document.createElement('h4');\n  var lang = model.get('lang') || [];\n  header.innerHTML = lang[0] || model.get('title');\n  header.style.cssText = 'margin: 10px 20px;';\n  header.style.color = model.get('textColor');\n  var viewMain = document.createElement('div');\n  var textarea = document.createElement('textarea');\n  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n  var optionToContent = model.get('optionToContent');\n  var contentToOption = model.get('contentToOption');\n  var result = getContentFromModel(ecModel);\n\n  if (typeof optionToContent === 'function') {\n    var htmlOrDom = optionToContent(api.getOption());\n\n    if (typeof htmlOrDom === 'string') {\n      viewMain.innerHTML = htmlOrDom;\n    } else if (zrUtil.isDom(htmlOrDom)) {\n      viewMain.appendChild(htmlOrDom);\n    }\n  } else {\n    // Use default textarea\n    viewMain.appendChild(textarea);\n    textarea.readOnly = model.get('readOnly');\n    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n    textarea.style.color = model.get('textColor');\n    textarea.style.borderColor = model.get('textareaBorderColor');\n    textarea.style.backgroundColor = model.get('textareaColor');\n    textarea.value = result.value;\n  }\n\n  var blockMetaList = result.meta;\n  var buttonContainer = document.createElement('div');\n  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n  var closeButton = document.createElement('div');\n  var refreshButton = document.createElement('div');\n  buttonStyle += ';background-color:' + model.get('buttonColor');\n  buttonStyle += ';color:' + model.get('buttonTextColor');\n  var self = this;\n\n  function close() {\n    container.removeChild(root);\n    self._dom = null;\n  }\n\n  eventTool.addEventListener(closeButton, 'click', close);\n  eventTool.addEventListener(refreshButton, 'click', function () {\n    var newOption;\n\n    try {\n      if (typeof contentToOption === 'function') {\n        newOption = contentToOption(viewMain, api.getOption());\n      } else {\n        newOption = parseContents(textarea.value, blockMetaList);\n      }\n    } catch (e) {\n      close();\n      throw new Error('Data view format error ' + e);\n    }\n\n    if (newOption) {\n      api.dispatchAction({\n        type: 'changeDataView',\n        newOption: newOption\n      });\n    }\n\n    close();\n  });\n  closeButton.innerHTML = lang[1];\n  refreshButton.innerHTML = lang[2];\n  refreshButton.style.cssText = buttonStyle;\n  closeButton.style.cssText = buttonStyle;\n  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\n  eventTool.addEventListener(textarea, 'keydown', function (e) {\n    if ((e.keyCode || e.which) === 9) {\n      // get caret position/selection\n      var val = this.value;\n      var start = this.selectionStart;\n      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret\n\n      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again\n\n      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose\n\n      eventTool.stop(e);\n    }\n  });\n  root.appendChild(header);\n  root.appendChild(viewMain);\n  root.appendChild(buttonContainer);\n  viewMain.style.height = container.clientHeight - 80 + 'px';\n  container.appendChild(root);\n  this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n  this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n  this.remove(ecModel, api);\n};\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return zrUtil.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n        newVal = newVal.value;\n      } // Original data has option\n\n\n      return zrUtil.defaults({\n        value: newVal\n      }, original);\n    } else {\n      return newVal;\n    }\n  });\n}\n\nfeatureManager.register('dataView', DataView);\necharts.registerAction({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  zrUtil.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(zrUtil.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(zrUtil.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\nvar _default = DataView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2447:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar BrushController = __webpack_require__(2448);\n\nvar BrushTargetManager = __webpack_require__(2449);\n\nvar history = __webpack_require__(2279);\n\nvar sliderMove = __webpack_require__(2205);\n\nvar lang = __webpack_require__(719);\n\nvar featureManager = __webpack_require__(2099);\n\n__webpack_require__(2452);\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each = zrUtil.each; // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n  /**\n   * @private\n   * @type {module:echarts/component/helper/BrushController}\n   */\n  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n  show: true,\n  // Icon group\n  icon: {\n    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n  },\n  // `zoom`, `back`\n  title: zrUtil.clone(dataZoomLang.title)\n};\nvar proto = DataZoom.prototype;\n\nproto.render = function (featureModel, ecModel, api, payload) {\n  this.model = featureModel;\n  this.ecModel = ecModel;\n  this.api = api;\n  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n  updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto.onclick = function (ecModel, api, type) {\n  handlers[type].call(this);\n};\n\nproto.remove = function (ecModel, api) {\n  this._brushController.unmount();\n};\n\nproto.dispose = function (ecModel, api) {\n  this._brushController.dispose();\n};\n/**\n * @private\n */\n\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(history.pop(this.ecModel));\n  }\n};\n/**\n * @private\n */\n\nproto._onBrush = function (areas, opt) {\n  if (!opt.isEnd || !areas.length) {\n    return;\n  }\n\n  var snapshot = {};\n  var ecModel = this.ecModel;\n\n  this._brushController.updateCovers([]); // remove cover\n\n\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {\n    include: ['grid']\n  });\n  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    if (coordSys.type !== 'cartesian2d') {\n      return;\n    }\n\n    var brushType = area.brushType;\n\n    if (brushType === 'rect') {\n      setBatch('x', coordSys, coordRange[0]);\n      setBatch('y', coordSys, coordRange[1]);\n    } else {\n      setBatch({\n        lineX: 'x',\n        lineY: 'y'\n      }[brushType], coordSys, coordRange);\n    }\n  });\n  history.push(ecModel, snapshot);\n\n  this._dispatchZoomAction(snapshot);\n\n  function setBatch(dimName, coordSys, minMax) {\n    var axis = coordSys.getAxis(dimName);\n    var axisModel = axis.model;\n    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n    }\n\n    dataZoomModel && (snapshot[dataZoomModel.id] = {\n      dataZoomId: dataZoomModel.id,\n      startValue: minMax[0],\n      endValue: minMax[1]\n    });\n  }\n\n  function findDataZoom(dimName, axisModel, ecModel) {\n    var found;\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'select'\n    }, function (dzModel) {\n      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n      has && (found = dzModel);\n    });\n    return found;\n  }\n};\n/**\n * @private\n */\n\n\nproto._dispatchZoomAction = function (snapshot) {\n  var batch = []; // Convert from hash map to array.\n\n  each(snapshot, function (batchItem, dataZoomId) {\n    batch.push(zrUtil.clone(batchItem));\n  });\n  batch.length && this.api.dispatchAction({\n    type: 'dataZoom',\n    from: this.uid,\n    batch: batch\n  });\n};\n\nfunction retrieveAxisSetting(option) {\n  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.\n\n  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n    setting[name] = option[name];\n    setting[name] == null && (setting[name] = 'all');\n    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n  });\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {\n    include: ['grid']\n  });\n\n  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  })).enableBrush(zoomActive ? {\n    brushType: 'auto',\n    brushStyle: {\n      // FIXME user customized?\n      lineWidth: 0,\n      fill: 'rgba(0,0,0,0.2)'\n    }\n  } : false);\n}\n\nfeatureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select\n\necharts.registerPreprocessor(function (option) {\n  if (!option) {\n    return;\n  }\n\n  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\n  if (!zrUtil.isArray(dataZoomOpts)) {\n    option.dataZoom = dataZoomOpts = [dataZoomOpts];\n  }\n\n  var toolboxOpt = option.toolbox;\n\n  if (toolboxOpt) {\n    // Assume there is only one toolbox\n    if (zrUtil.isArray(toolboxOpt)) {\n      toolboxOpt = toolboxOpt[0];\n    }\n\n    if (toolboxOpt && toolboxOpt.feature) {\n      var dataZoomOpt = toolboxOpt.feature.dataZoom;\n      addForAxis('xAxis', dataZoomOpt);\n      addForAxis('yAxis', dataZoomOpt);\n    }\n  }\n\n  function addForAxis(axisName, dataZoomOpt) {\n    if (!dataZoomOpt) {\n      return;\n    } // Try not to modify model, because it is not merged yet.\n\n\n    var axisIndicesName = axisName + 'Index';\n    var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\n    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {\n      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];\n    }\n\n    forEachComponent(axisName, function (axisOpt, axisIndex) {\n      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {\n        return;\n      }\n\n      var newOpt = {\n        type: 'select',\n        $fromToolbox: true,\n        // Id for merge mapping.\n        id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n      }; // FIXME\n      // Only support one axis now.\n\n      newOpt[axisIndicesName] = axisIndex;\n      dataZoomOpts.push(newOpt);\n    });\n  }\n\n  function forEachComponent(mainType, cb) {\n    var opts = option[mainType];\n\n    if (!zrUtil.isArray(opts)) {\n      opts = opts ? [opts] : [];\n    }\n\n    each(opts, cb);\n  }\n});\nvar _default = DataZoom;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2448:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(9);\n\nvar Eventful = __webpack_require__(151);\n\nvar graphic = __webpack_require__(41);\n\nvar interactionMutex = __webpack_require__(2276);\n\nvar DataDiffer = __webpack_require__(731);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2449:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(9);\n\nvar graphic = __webpack_require__(41);\n\nvar modelUtil = __webpack_require__(28);\n\nvar brushHelper = __webpack_require__(2450);\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2450:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BoundingRect = __webpack_require__(58);\n\nvar _cursorHelper = __webpack_require__(2451);\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar graphicUtil = __webpack_require__(41);\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints, transform) {\n    return graphicUtil.clipPointsByRect(localPoints, rect);\n  };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  rect = normalizeRect(rect);\n  return function (e, localCursorPoint, transform) {\n    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\n\nfunction normalizeRect(rect) {\n  return BoundingRect.create(rect);\n}\n\nexports.makeRectPanelClipPath = makeRectPanelClipPath;\nexports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;\nexports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;\n\n/***/ }),\n\n/***/ 2451:\n/***/ (function(module, exports) {\n\nvar IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;\n}\n\nexports.onIrrelevantElement = onIrrelevantElement;\n\n/***/ }),\n\n/***/ 2452:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(2275);\n\n__webpack_require__(2134);\n\n__webpack_require__(2135);\n\n__webpack_require__(2453);\n\n__webpack_require__(2454);\n\n__webpack_require__(2277);\n\n__webpack_require__(2278);\n\n/***/ }),\n\n/***/ 2453:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(2134);\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2454:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomView = __webpack_require__(2135);\n\nvar _default = DataZoomView.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2455:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar history = __webpack_require__(2279);\n\nvar lang = __webpack_require__(719);\n\nvar featureManager = __webpack_require__(2099);\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n  this.model = model;\n}\n\nRestore.defaultOption = {\n  show: true,\n  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n  title: restoreLang.title\n};\nvar proto = Restore.prototype;\n\nproto.onclick = function (ecModel, api, type) {\n  history.clear(ecModel);\n  api.dispatchAction({\n    type: 'restore',\n    from: this.uid\n  });\n};\n\nfeatureManager.register('restore', Restore);\necharts.registerAction({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\nvar _default = Restore;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2456:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\n__webpack_require__(2457);\n\n__webpack_require__(2459);\n\n// HINT Markpoint can't be used too much\necharts.registerPreprocessor(function (opt) {\n  // Make sure markPoint component is enabled\n  opt.markPoint = opt.markPoint || {};\n});\n\n/***/ }),\n\n/***/ 2457:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MarkerModel = __webpack_require__(2458);\n\nvar _default = MarkerModel.extend({\n  type: 'markPoint',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    //symbolRotate: 0,\n    //symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'inside'\n    },\n    itemStyle: {\n      borderWidth: 2\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2458:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(43);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar env = __webpack_require__(51);\n\nvar modelUtil = __webpack_require__(28);\n\nvar formatUtil = __webpack_require__(70);\n\nvar dataFormatMixin = __webpack_require__(742);\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2459:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar SymbolDraw = __webpack_require__(2116);\n\nvar numberUtil = __webpack_require__(50);\n\nvar List = __webpack_require__(379);\n\nvar markerHelper = __webpack_require__(2460);\n\nvar MarkerView = __webpack_require__(2461);\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar _default = MarkerView.extend({\n  type: 'markPoint',\n  // updateLayout: function (markPointModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mpModel = seriesModel.markPointModel;\n  //         if (mpModel) {\n  //             updateMarkerLayout(mpModel.getData(), seriesModel, api);\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = seriesModel.markPointModel;\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbolSize = itemModel.getShallow('symbolSize');\n\n      if (typeof symbolSize === 'function') {\n        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));\n      }\n\n      mpData.setItemVisual(idx, {\n        symbolSize: symbolSize,\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'),\n        symbol: itemModel.getShallow('symbol')\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        child.dataModel = mpModel;\n      });\n    });\n    symbolDraw.__keep = true;\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new List(coordDimsInfos, mpModel);\n  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 2460:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(9);\n\nvar numberUtil = __webpack_require__(50);\n\nvar _dataStackHelper = __webpack_require__(241);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim, otherDataDim);\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n/***/ }),\n\n/***/ 2461:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(55);\n\nvar zrUtil = __webpack_require__(9);\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Stats.c510f026.chunk.js","import React from \"react\";\n\nimport {tu} from \"../../../utils/i18n\";\nimport {Client} from \"../../../services/api\";\nimport {ONE_TRX} from \"../../../constants\";\nimport {connect} from \"react-redux\";\nimport {injectIntl} from \"react-intl\";\nimport {filter, includes} from \"lodash\";\nimport {tronAddresses} from \"../../../utils/tron\";\nimport RichList from \"./RichList\";\nimport {TronLoader} from \"../../common/loaders\";\nimport PieReact from \"../../common/PieChart\";\nimport LineReact from \"../../common/LineChart\";\nimport LineReactTx from \"../../common/LineChartTx\";\n\nclass Statistics extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      accounts: null,\n      transactionStats: null,\n      blockStats: null,\n      transactionValueStats: null,\n      txOverviewStats: null\n    };\n  }\n\n  componentDidMount() {\n    this.loadAccounts();\n    this.loadStats();\n    this.loadTxOverviewStats();\n  }\n\n  async loadAccounts() {\n\n    let {accounts} = await Client.getAccounts({\n      limit: 35,\n      sort: '-balance',\n    });\n\n    this.setState({\n      accounts: filter(accounts, account => !includes(tronAddresses, account.address))\n          .slice(0, 10)\n          .map(account => ({\n            name: account.address,\n            value: account.balance / ONE_TRX,\n          }))\n    });\n  }\n\n\n  async loadStats() {\n\n    let {intl} = this.props;\n\n    let {stats} = await Client.getTransferStats({\n      groupby: 'timestamp',\n      interval: 'hour',\n    });\n\n    let {stats: blockStats} = await Client.getBlockStats({\n      info: `avg-block-size`,\n    });\n\n    let transactionTotalStats = stats.total.map(row => ({\n      timestamp: row.timestamp,\n      value: row.value,\n    }));\n\n    let valueStats = stats.value.map(row => ({\n      timestamp: row.timestamp,\n      value: row.value / ONE_TRX,\n    }));\n\n    blockStats = blockStats.map(row => ({\n      timestamp: row.timestamp,\n      value: row.value,\n    }));\n\n    this.setState({\n      transactionStats: transactionTotalStats,\n      transactionValueStats: valueStats,\n      blockStats,\n    });\n  }\n\n  async loadTxOverviewStats() {\n    let {txOverviewStats} = await Client.getTxOverviewStats();\n    let temp = [];\n    for (let txs in txOverviewStats) {\n      let tx = parseInt(txs);\n      if (tx === 0)\n        temp.push(txOverviewStats[tx]);\n      else\n        temp.push({\n          date: txOverviewStats[tx].date,\n          totalTransaction: (txOverviewStats[tx].totalTransaction - txOverviewStats[tx - 1].totalTransaction),\n          avgBlockTime: txOverviewStats[tx].avgBlockTime,\n          avgBlockSize: txOverviewStats[tx].avgBlockSize,\n          totalBlockCount: (txOverviewStats[tx].totalBlockCount - txOverviewStats[tx - 1].totalBlockCount),\n          newAddressSeen: txOverviewStats[tx].newAddressSeen\n        });\n    }\n\n    this.setState({\n      txOverviewStats: temp\n    });\n  }\n\n  render() {\n\n    let {txOverviewStats, transactionStats, transactionValueStats, blockStats, accounts} = this.state;\n\n    return (\n        <main className=\"container header-overlap\">\n          <div className=\"row\">\n            <div className=\"col-md-12 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n\n                  <div style={{height: 350}}>\n                    {\n                      txOverviewStats === null ?\n                          <TronLoader/> :\n                          <LineReactTx style={{height: 350}} data={txOverviewStats}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Top\")} {accounts !== null ? accounts.length : 0} {tu(\"addresses\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      accounts === null ?\n                          <TronLoader/> :\n                          <PieReact style={{height: 300}} data={accounts}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"trx_transferred_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionValueStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionValueStats}\n                                     keysData={['timestamp', 'value']} format={{timestamp: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"transactions_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionStats} keysData={['timestamp', 'value']}\n                                     format={{timestamp: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"average_blocksize\")} ({tu(\"bytes\")})</h5>\n                  <div style={{height: 300}}>\n                    {\n                      blockStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={blockStats} keysData={['timestamp', 'value']}\n                                     format={{timestamp: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {};\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(injectIntl(Statistics))\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 2090\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 2091\n// module chunks = 2 3 4","var features = {};\n\nfunction register(name, ctor) {\n  features[name] = ctor;\n}\n\nfunction get(name) {\n  return features[name];\n}\n\nexports.register = register;\nexports.get = get;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/featureManager.js\n// module id = 2099\n// module chunks = 2","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 2115\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 2116\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // 拐点图形类型\n    symbol: 'emptyCircle',\n    // 拐点图形大小\n    symbolSize: 4,\n    // 拐点图形旋转控制\n    symbolRotate: null,\n    // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n    showSymbol: true,\n    // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n    showAllSymbol: false,\n    // 是否连接断点\n    connectNulls: false,\n    // 数据过滤，'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 2127\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 2128\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 2129\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 2130\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 2131\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 2132\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 2133\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar helper = require(\"./helper\");\n\nvar AxisProxy = require(\"./AxisProxy\");\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n      // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n    // 例如series.type === scatter时。\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\n// module id = 2134\n// module chunks = 2","var ComponentView = require(\"../../view/Component\");\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\n// module id = 2135\n// module chunks = 2","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 2136\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 2193\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n      // 默认使用全局文本样式，详见TEXTSTYLE\n      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // 引导线两段中的第一段长度\n      length: 15,\n      // 引导线两段中的第二段长度\n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: 各异,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 2194\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 2195\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 2196\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 2197\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 2198\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 2199\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 2200\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 2201\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 2202\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            if((val[keysData[0]]+\"\").length===10)\n              config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n            if((val[keysData[0]]+\"\").length===13)\n              config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]));\n          }\n        }\n        else {\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n        }\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/helper.js\n// module id = 2204\n// module chunks = 2","/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/sliderMove.js\n// module id = 2205\n// module chunks = 2","var Component = require(\"../../model/Component\");\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\n// module id = 2275\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/interactionMutex.js\n// module id = 2276\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\necharts.registerProcessor({\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);\n        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n          seriesModelMap.set(seriesModel.uid, seriesModel);\n        });\n      });\n    });\n    return seriesModelMap;\n  },\n  isOverallFilter: true,\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      var percentRange = axisProxy.getDataPercentWindow();\n      var valueRange = axisProxy.getDataValueWindow();\n      dataZoomModel.setRawRange({\n        start: percentRange[0],\n        end: percentRange[1],\n        startValue: valueRange[0],\n        endValue: valueRange[1]\n      }, true);\n    });\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n// module id = 2277\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar helper = require(\"./helper\");\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n// module id = 2278\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar each = zrUtil.each;\nvar ATTR = '\\0_ec_hist_store';\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\n\nfunction push(ecModel, newSnapshot) {\n  var store = giveStore(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = store.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = store[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        store[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  store.push(newSnapshot);\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\n\n\nfunction pop(ecModel) {\n  var store = giveStore(ecModel);\n  var head = store[store.length - 1];\n  store.length > 1 && store.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = store.length - 1; i >= 0; i--) {\n      var batchItem = store[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction clear(ecModel) {\n  ecModel[ATTR] = null;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\n\n\nfunction count(ecModel) {\n  return giveStore(ecModel).length;\n}\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(ecModel) {\n  var store = ecModel[ATTR];\n\n  if (!store) {\n    store = ecModel[ATTR] = [{}];\n  }\n\n  return store;\n}\n\nexports.push = push;\nexports.pop = pop;\nexports.clear = clear;\nexports.count = count;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/history.js\n// module id = 2279\n// module chunks = 2","\n\nexport const tronAddresses = [\n  '27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS',\n  '27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj',\n  '27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx',\n  '27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/tron.js","import React, {Component} from \"react\";\nimport {Client} from \"../../../services/api\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../../common/Price\";\nimport {tu} from \"../../../utils/i18n\";\n\nexport default class RichList extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      richList: [],\n      totals: {\n        accounts: 0,\n        coins: 0,\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.load();\n  }\n\n  async load() {\n    let {data, total} = await Client.getRichList();\n\n    this.setState({\n      richList: data,\n      totals: total,\n    });\n  }\n\n  render() {\n\n    let {richList, totals} = this.state;\n\n    return (\n        <div className=\"card\">\n          <div className=\"card-body\">\n            <h5 className=\"card-title text-center\">\n              {tu(\"rich_list\")}\n            </h5>\n          </div>\n          <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th>{tu(\"balance\")}</th>\n                <th className=\"d-none d-lg-table-cell\">{tu(\"addresses\")}</th>\n                <th className=\"text-nowrap text-right\">% {tu(\"addresses\")}</th>\n                <th className=\"text-right d-none d-md-table-cell\">{tu(\"TRX\")}</th>\n                <th className=\"text-right\">$ {tu(\"USD\")}</th>\n                <th className=\"text-right  d-none d-md-table-cell\">% {tu(\"Coins\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              richList.map((row, index) => (\n                <tr key={index}>\n                  <th>\n                    <FormattedNumber value={row.from}/>{' - '}\n                    <FormattedNumber value={row.to} />\n                  </th>\n                  <td className=\"d-none d-lg-table-cell\">\n                    {row.accounts}\n                  </td>\n                  <td className=\"text-right text-nowrap\" style={{width: 100}}>\n                    <FormattedNumber value={(row.accounts / totals.accounts) * 100}\n                                     maximumFractionDigits={2}\n                                     minimumFractionDigits={2} /> %\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={row.balance} />\n                  </td>\n                  <td className=\"text-right text-nowrap\">\n                    <TRXPrice amount={row.balance} currency=\"USD\" />\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={(row.balance / totals.coins) * 100}\n                                     maximumFractionDigits={4}\n                                     minimumFractionDigits={4}/> %\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n        </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/RichList.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\n\nexport class PieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'pie' + id\n    }\n  }\n\n  initPie(id) {\n    let { data }=this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.pieChart.series[0].data = [];\n    config.pieChart.title.text=\"\";\n\n    if (data && data.length > 0) {\n      config.pieChart.series[0].data = data;\n    }\n    if(data && data.length===0){\n      config.pieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.pieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default PieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/PieChart.js","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/dataZoom'\nimport 'echarts/lib/component/toolbox'\nimport 'echarts/lib/component/markPoint'\n\nimport {connect} from \"react-redux\";\n\nexport class LineReactTx extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'lineTx' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, data} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.txOverviewChart.title.text = intl.formatMessage({id:'TRX_transaction_chart'});\n    config.txOverviewChart.xAxis[0].data = [];\n    config.txOverviewChart.series[0].data = [];\n    config.txOverviewChart.yAxis[0].name = intl.formatMessage({id: 'transactions_per_day'});\n    config.txOverviewChart.tooltip.formatter = function (datas) {\n      let date = new Date(parseInt(datas[0].data.date)).toLocaleString().split(' ')[0];\n      return (\n          intl.formatMessage({id: 'date'}) + ' : ' + date + '<br/>' +\n          intl.formatMessage({id: 'total_transactions'}) + ' : ' + datas[0].data.totalTransaction + '<br/>' +\n          intl.formatMessage({id: 'avg_blockTime'}) + ' : ' + datas[0].data.avgBlockTime + '<br/>' +\n          intl.formatMessage({id: 'avg_blockSize'}) + ' : ' + datas[0].data.avgBlockSize + '<br/>' +\n          intl.formatMessage({id: 'total_BlockCount'}) + ' : ' + datas[0].data.totalBlockCount + '<br/>' +\n          intl.formatMessage({id: 'new_address_seen'}) + ' : ' + datas[0].data.newAddressSeen + '<br/>'\n      )\n\n    }\n\n    if (data && data.length > 0) {\n      data.map((val) => {\n        let temp;\n        temp = {...val, value: val.totalTransaction};\n        config.txOverviewChart.xAxis[0].data.push(intl.formatDate(val.date));\n        config.txOverviewChart.series[0].data.push(temp);\n      })\n    }\n    if (data && data.length === 0) {\n      config.txOverviewChart.title.text = \"No data\";\n    }\n    myChart.setOption(config.txOverviewChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReactTx));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChartTx.js","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SliderZoomModel\");\n\nrequire(\"./dataZoom/SliderZoomView\");\n\nrequire(\"./dataZoom/InsideZoomModel\");\n\nrequire(\"./dataZoom/InsideZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom.js\n// module id = 2433\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n    // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n// module id = 2434\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\n// module id = 2435\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar throttle = require(\"../../util/throttle\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar layout = require(\"../../util/layout\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // 应该使用统一的空判断？还是在list里进行空判断？\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    realtime && this._dispatchZoomAction();\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\n// module id = 2436\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\n// module id = 2437\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar roams = require(\"./roams\");\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\n// module id = 2438\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar RoamController = require(\"../../component/helper/RoamController\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {}; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/roams.js\n// module id = 2439\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n  /**\n   * @type {Function}\n   */\n  this.pointerChecker;\n  /**\n   * @type {module:zrender}\n   */\n\n  this._zr = zr;\n  /**\n   * @type {Object}\n   */\n\n  this._opt = {}; // Avoid two roamController bind the same handler\n\n  var bind = zrUtil.bind;\n  var mousedownHandler = bind(mousedown, this);\n  var mousemoveHandler = bind(mousemove, this);\n  var mouseupHandler = bind(mouseup, this);\n  var mousewheelHandler = bind(mousewheel, this);\n  var pinchHandler = bind(pinch, this);\n  Eventful.call(this);\n  /**\n   * @param {Function} pointerChecker\n   *                   input: x, y\n   *                   output: boolean\n   */\n\n  this.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  /**\n   * Notice: only enable needed types. For example, if 'zoom'\n   * is not needed, 'zoom' should not be enabled, otherwise\n   * default mousewheel behaviour (scroll page) will be disabled.\n   *\n   * @param  {boolean|string} [controlType=true] Specify the control type,\n   *                          which can be null/undefined or true/false\n   *                          or 'pan/move' or 'zoom'/'scale'\n   * @param {Object} [opt]\n   * @param {Object} [opt.zoomOnMouseWheel=true]\n   * @param {Object} [opt.moveOnMouseMove=true]\n   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n   */\n\n\n  this.enable = function (controlType, opt) {\n    // Disable previous first\n    this.disable();\n    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      preventDefaultMouseMove: true\n    });\n\n    if (controlType == null) {\n      controlType = true;\n    }\n\n    if (controlType === true || controlType === 'move' || controlType === 'pan') {\n      zr.on('mousedown', mousedownHandler);\n      zr.on('mousemove', mousemoveHandler);\n      zr.on('mouseup', mouseupHandler);\n    }\n\n    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n      zr.on('mousewheel', mousewheelHandler);\n      zr.on('pinch', pinchHandler);\n    }\n  };\n\n  this.disable = function () {\n    zr.off('mousedown', mousedownHandler);\n    zr.off('mousemove', mousemoveHandler);\n    zr.off('mouseup', mouseupHandler);\n    zr.off('mousewheel', mousewheelHandler);\n    zr.off('pinch', pinchHandler);\n  };\n\n  this.dispose = this.disable;\n\n  this.isDragging = function () {\n    return this._dragging;\n  };\n\n  this.isPinching = function () {\n    return this._pinching;\n  };\n}\n\nzrUtil.mixin(RoamController, Eventful);\n\nfunction mousedown(e) {\n  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY; // Only check on mosedown, but not mousemove.\n  // Mouse can be out of target when mouse moving.\n\n  if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n    this._x = x;\n    this._y = y;\n    this._dragging = true;\n  }\n}\n\nfunction mousemove(e) {\n  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY;\n  var oldX = this._x;\n  var oldY = this._y;\n  var dx = x - oldX;\n  var dy = y - oldY;\n  this._x = x;\n  this._y = y;\n  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);\n  this.trigger('pan', dx, dy, oldX, oldY, x, y);\n}\n\nfunction mouseup(e) {\n  if (!eventTool.notLeftMouse(e)) {\n    this._dragging = false;\n  }\n}\n\nfunction mousewheel(e) {\n  // wheelDelta maybe -0 in chrome mac.\n  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {\n    return;\n  } // Convenience:\n  // Mac and VM Windows on Mac: scroll up: zoom out.\n  // Windows: scroll up: zoom in.\n\n\n  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n}\n\nfunction pinch(e) {\n  if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n}\n\nfunction zoom(e, zoomDelta, zoomX, zoomY) {\n  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    eventTool.stop(e.event);\n    this.trigger('zoom', zoomDelta, zoomX, zoomY);\n  }\n}\n\nfunction checkKeyBinding(roamController, prop, e) {\n  var setting = roamController._opt[prop];\n  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);\n}\n\nvar _default = RoamController;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/RoamController.js\n// module id = 2440\n// module chunks = 2","require(\"./toolbox/ToolboxModel\");\n\nrequire(\"./toolbox/ToolboxView\");\n\nrequire(\"./toolbox/feature/SaveAsImage\");\n\nrequire(\"./toolbox/feature/MagicType\");\n\nrequire(\"./toolbox/feature/DataView\");\n\nrequire(\"./toolbox/feature/DataZoom\");\n\nrequire(\"./toolbox/feature/Restore\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox.js\n// module id = 2441\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar ToolboxModel = echarts.extendComponentModel({\n  type: 'toolbox',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  mergeDefaultAndTheme: function (option) {\n    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n    zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager.get(featureName);\n      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n    });\n  },\n  defaultOption: {\n    show: true,\n    z: 6,\n    zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      } // textStyle: {},\n      // feature\n\n    }\n  }\n});\nvar _default = ToolboxModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n// module id = 2442\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar listComponentHelper = require(\"../helper/listComponent\");\n\nvar _default = echarts.extendComponentView({\n  type: 'toolbox',\n  render: function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    zrUtil.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            model: featureModel,\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = featureManager.get(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature(featureModel, ecModel, api);\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n\n        feature.model = featureModel;\n        feature.ecModel = ecModel;\n        feature.api = api;\n      }\n\n      if (!featureName && oldName) {\n        feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || feature.unusable) {\n        feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status; // FIXME\n\n        iconPaths[iconName] && iconPaths[iconName].trigger(status);\n      };\n\n      if (feature.render) {\n        feature.render(featureModel, ecModel, api, payload);\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n\n      if (typeof icons === 'string') {\n        var icon = icons;\n        var title = titles;\n        icons = {};\n        titles = {};\n        icons[featureName] = icon;\n        titles[featureName] = title;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      zrUtil.each(icons, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        });\n        path.setStyle(iconStyleModel.getItemStyle());\n        path.hoverStyle = iconStyleEmphasisModel.getItemStyle();\n        graphic.setHoverStyle(path);\n\n        if (toolboxModel.get('showTitle')) {\n          path.__title = titles[iconName];\n          path.on('mouseover', function () {\n            // Should not reuse above hoverStyle, which might be modified.\n            var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n            path.setStyle({\n              text: titles[iconName],\n              textPosition: hoverStyle.textPosition || 'bottom',\n              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n              textAlign: hoverStyle.textAlign || 'center'\n            });\n          }).on('mouseout', function () {\n            path.setStyle({\n              textFill: null\n            });\n          });\n        }\n\n        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n        group.add(path);\n        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      var hoverStyle = icon.hoverStyle; // May be background element\n\n      if (hoverStyle && titleText) {\n        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));\n        var offsetX = icon.position[0] + group.position[0];\n        var offsetY = icon.position[1] + group.position[1] + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          hoverStyle.textPosition = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          hoverStyle.textPosition = ['100%', topOffset];\n          hoverStyle.textAlign = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          hoverStyle.textPosition = [0, topOffset];\n          hoverStyle.textAlign = 'left';\n        }\n      }\n    });\n  },\n  updateView: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  },\n  // updateLayout: function (toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n  remove: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  },\n  dispose: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.dispose && feature.dispose(ecModel, api);\n    });\n  }\n});\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n// module id = 2443\n// module chunks = 2","var env = require(\"zrender/lib/core/env\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n  this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n  show: true,\n  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n  title: saveAsImageLang.title,\n  type: 'png',\n  // Default use option.backgroundColor\n  // backgroundColor: '#fff',\n  name: '',\n  excludeComponents: ['toolbox'],\n  pixelRatio: 1,\n  lang: saveAsImageLang.lang.slice()\n};\nSaveAsImage.prototype.unusable = !env.canvasSupported;\nvar proto = SaveAsImage.prototype;\n\nproto.onclick = function (ecModel, api) {\n  var model = this.model;\n  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n  var $a = document.createElement('a');\n  var type = model.get('type', true) || 'png';\n  $a.download = title + '.' + type;\n  $a.target = '_blank';\n  var url = api.getConnectedDataURL({\n    type: type,\n    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n    excludeComponents: model.get('excludeComponents'),\n    pixelRatio: model.get('pixelRatio')\n  });\n  $a.href = url; // Chrome and Firefox\n\n  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: false\n    });\n    $a.dispatchEvent(evt);\n  } // IE\n  else {\n      if (window.navigator.msSaveOrOpenBlob) {\n        var bstr = atob(url.split(',')[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blob = new Blob([u8arr]);\n        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n      }\n    }\n};\n\nfeatureManager.register('saveAsImage', SaveAsImage);\nvar _default = SaveAsImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n// module id = 2444\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n  this.model = model;\n}\n\nMagicType.defaultOption = {\n  show: true,\n  type: [],\n  // Icon group\n  icon: {\n    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',\n    // jshint ignore:line\n    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n  },\n  // `line`, `bar`, `stack`, `tiled`\n  title: zrUtil.clone(magicTypeLang.title),\n  option: {},\n  seriesIndex: {}\n};\nvar proto = MagicType.prototype;\n\nproto.getIcons = function () {\n  var model = this.model;\n  var availableIcons = model.get('icon');\n  var icons = {};\n  zrUtil.each(model.get('type'), function (type) {\n    if (availableIcons[type]) {\n      icons[type] = availableIcons[type];\n    }\n  });\n  return icons;\n};\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.line') || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.bar') || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: '__ec_magicType_stack__'\n      }, model.get('option.stack') || {}, true);\n    }\n  },\n  'tiled': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: ''\n      }, model.get('option.tiled') || {}, true);\n    }\n  }\n};\nvar radioTypes = [['line', 'bar'], ['stack', 'tiled']];\n\nproto.onclick = function (ecModel, api, type) {\n  var model = this.model;\n  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType\n\n  if (!seriesOptGenreator[type]) {\n    return;\n  }\n\n  var newOption = {\n    series: []\n  };\n\n  var generateNewSeriesTypes = function (seriesModel) {\n    var seriesType = seriesModel.subType;\n    var seriesId = seriesModel.id;\n    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n    if (newSeriesOpt) {\n      // PENDING If merge original option?\n      zrUtil.defaults(newSeriesOpt, seriesModel.option);\n      newOption.series.push(newSeriesOpt);\n    } // Modify boundaryGap\n\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (categoryAxis) {\n        var axisDim = categoryAxis.dim;\n        var axisType = axisDim + 'Axis';\n        var axisModel = ecModel.queryComponents({\n          mainType: axisType,\n          index: seriesModel.get(name + 'Index'),\n          id: seriesModel.get(name + 'Id')\n        })[0];\n        var axisIndex = axisModel.componentIndex;\n        newOption[axisType] = newOption[axisType] || [];\n\n        for (var i = 0; i <= axisIndex; i++) {\n          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n        }\n\n        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n      }\n    }\n  };\n\n  zrUtil.each(radioTypes, function (radio) {\n    if (zrUtil.indexOf(radio, type) >= 0) {\n      zrUtil.each(radio, function (item) {\n        model.setIconStatus(item, 'normal');\n      });\n    }\n  });\n  model.setIconStatus(type, 'emphasis');\n  ecModel.eachComponent({\n    mainType: 'series',\n    query: seriesIndex == null ? null : {\n      seriesIndex: seriesIndex\n    }\n  }, generateNewSeriesTypes);\n  api.dispatchAction({\n    type: 'changeMagicType',\n    currentType: type,\n    newOption: newOption\n  });\n};\n\necharts.registerAction({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\nfeatureManager.register('magicType', MagicType);\nvar _default = MagicType;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n// module id = 2445\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar dataViewLang = lang.toolbox.dataView;\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(series) {\n  var tables = [];\n  zrUtil.each(series, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n      return series.name;\n    }));\n    var columns = [categoryAxis.model.getCategories()];\n    zrUtil.each(group.series, function (series) {\n      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleOtherSeries(series) {\n  return zrUtil.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\n\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = zrUtil.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\n\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var items = trim(lines[i]).split(itemSplitRegex);\n    var name = '';\n    var value;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\n\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  zrUtil.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\n\n\nfunction DataView(model) {\n  this._dom = null;\n  this.model = model;\n}\n\nDataView.defaultOption = {\n  show: true,\n  readOnly: false,\n  optionToContent: null,\n  contentToOption: null,\n  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n  title: zrUtil.clone(dataViewLang.title),\n  lang: zrUtil.clone(dataViewLang.lang),\n  backgroundColor: '#fff',\n  textColor: '#000',\n  textareaColor: '#fff',\n  textareaBorderColor: '#333',\n  buttonColor: '#c23531',\n  buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n  var container = api.getDom();\n  var model = this.model;\n\n  if (this._dom) {\n    container.removeChild(this._dom);\n  }\n\n  var root = document.createElement('div');\n  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n  var header = document.createElement('h4');\n  var lang = model.get('lang') || [];\n  header.innerHTML = lang[0] || model.get('title');\n  header.style.cssText = 'margin: 10px 20px;';\n  header.style.color = model.get('textColor');\n  var viewMain = document.createElement('div');\n  var textarea = document.createElement('textarea');\n  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n  var optionToContent = model.get('optionToContent');\n  var contentToOption = model.get('contentToOption');\n  var result = getContentFromModel(ecModel);\n\n  if (typeof optionToContent === 'function') {\n    var htmlOrDom = optionToContent(api.getOption());\n\n    if (typeof htmlOrDom === 'string') {\n      viewMain.innerHTML = htmlOrDom;\n    } else if (zrUtil.isDom(htmlOrDom)) {\n      viewMain.appendChild(htmlOrDom);\n    }\n  } else {\n    // Use default textarea\n    viewMain.appendChild(textarea);\n    textarea.readOnly = model.get('readOnly');\n    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n    textarea.style.color = model.get('textColor');\n    textarea.style.borderColor = model.get('textareaBorderColor');\n    textarea.style.backgroundColor = model.get('textareaColor');\n    textarea.value = result.value;\n  }\n\n  var blockMetaList = result.meta;\n  var buttonContainer = document.createElement('div');\n  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n  var closeButton = document.createElement('div');\n  var refreshButton = document.createElement('div');\n  buttonStyle += ';background-color:' + model.get('buttonColor');\n  buttonStyle += ';color:' + model.get('buttonTextColor');\n  var self = this;\n\n  function close() {\n    container.removeChild(root);\n    self._dom = null;\n  }\n\n  eventTool.addEventListener(closeButton, 'click', close);\n  eventTool.addEventListener(refreshButton, 'click', function () {\n    var newOption;\n\n    try {\n      if (typeof contentToOption === 'function') {\n        newOption = contentToOption(viewMain, api.getOption());\n      } else {\n        newOption = parseContents(textarea.value, blockMetaList);\n      }\n    } catch (e) {\n      close();\n      throw new Error('Data view format error ' + e);\n    }\n\n    if (newOption) {\n      api.dispatchAction({\n        type: 'changeDataView',\n        newOption: newOption\n      });\n    }\n\n    close();\n  });\n  closeButton.innerHTML = lang[1];\n  refreshButton.innerHTML = lang[2];\n  refreshButton.style.cssText = buttonStyle;\n  closeButton.style.cssText = buttonStyle;\n  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\n  eventTool.addEventListener(textarea, 'keydown', function (e) {\n    if ((e.keyCode || e.which) === 9) {\n      // get caret position/selection\n      var val = this.value;\n      var start = this.selectionStart;\n      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret\n\n      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again\n\n      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose\n\n      eventTool.stop(e);\n    }\n  });\n  root.appendChild(header);\n  root.appendChild(viewMain);\n  root.appendChild(buttonContainer);\n  viewMain.style.height = container.clientHeight - 80 + 'px';\n  container.appendChild(root);\n  this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n  this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n  this.remove(ecModel, api);\n};\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return zrUtil.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n        newVal = newVal.value;\n      } // Original data has option\n\n\n      return zrUtil.defaults({\n        value: newVal\n      }, original);\n    } else {\n      return newVal;\n    }\n  });\n}\n\nfeatureManager.register('dataView', DataView);\necharts.registerAction({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  zrUtil.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(zrUtil.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(zrUtil.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\nvar _default = DataView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n// module id = 2446\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BrushController = require(\"../../helper/BrushController\");\n\nvar BrushTargetManager = require(\"../../helper/BrushTargetManager\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar sliderMove = require(\"../../helper/sliderMove\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nrequire(\"../../dataZoomSelect\");\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each = zrUtil.each; // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n  /**\n   * @private\n   * @type {module:echarts/component/helper/BrushController}\n   */\n  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n  show: true,\n  // Icon group\n  icon: {\n    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n  },\n  // `zoom`, `back`\n  title: zrUtil.clone(dataZoomLang.title)\n};\nvar proto = DataZoom.prototype;\n\nproto.render = function (featureModel, ecModel, api, payload) {\n  this.model = featureModel;\n  this.ecModel = ecModel;\n  this.api = api;\n  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n  updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto.onclick = function (ecModel, api, type) {\n  handlers[type].call(this);\n};\n\nproto.remove = function (ecModel, api) {\n  this._brushController.unmount();\n};\n\nproto.dispose = function (ecModel, api) {\n  this._brushController.dispose();\n};\n/**\n * @private\n */\n\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(history.pop(this.ecModel));\n  }\n};\n/**\n * @private\n */\n\nproto._onBrush = function (areas, opt) {\n  if (!opt.isEnd || !areas.length) {\n    return;\n  }\n\n  var snapshot = {};\n  var ecModel = this.ecModel;\n\n  this._brushController.updateCovers([]); // remove cover\n\n\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {\n    include: ['grid']\n  });\n  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    if (coordSys.type !== 'cartesian2d') {\n      return;\n    }\n\n    var brushType = area.brushType;\n\n    if (brushType === 'rect') {\n      setBatch('x', coordSys, coordRange[0]);\n      setBatch('y', coordSys, coordRange[1]);\n    } else {\n      setBatch({\n        lineX: 'x',\n        lineY: 'y'\n      }[brushType], coordSys, coordRange);\n    }\n  });\n  history.push(ecModel, snapshot);\n\n  this._dispatchZoomAction(snapshot);\n\n  function setBatch(dimName, coordSys, minMax) {\n    var axis = coordSys.getAxis(dimName);\n    var axisModel = axis.model;\n    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n    }\n\n    dataZoomModel && (snapshot[dataZoomModel.id] = {\n      dataZoomId: dataZoomModel.id,\n      startValue: minMax[0],\n      endValue: minMax[1]\n    });\n  }\n\n  function findDataZoom(dimName, axisModel, ecModel) {\n    var found;\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'select'\n    }, function (dzModel) {\n      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n      has && (found = dzModel);\n    });\n    return found;\n  }\n};\n/**\n * @private\n */\n\n\nproto._dispatchZoomAction = function (snapshot) {\n  var batch = []; // Convert from hash map to array.\n\n  each(snapshot, function (batchItem, dataZoomId) {\n    batch.push(zrUtil.clone(batchItem));\n  });\n  batch.length && this.api.dispatchAction({\n    type: 'dataZoom',\n    from: this.uid,\n    batch: batch\n  });\n};\n\nfunction retrieveAxisSetting(option) {\n  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.\n\n  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n    setting[name] = option[name];\n    setting[name] == null && (setting[name] = 'all');\n    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n  });\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {\n    include: ['grid']\n  });\n\n  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  })).enableBrush(zoomActive ? {\n    brushType: 'auto',\n    brushStyle: {\n      // FIXME user customized?\n      lineWidth: 0,\n      fill: 'rgba(0,0,0,0.2)'\n    }\n  } : false);\n}\n\nfeatureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select\n\necharts.registerPreprocessor(function (option) {\n  if (!option) {\n    return;\n  }\n\n  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\n  if (!zrUtil.isArray(dataZoomOpts)) {\n    option.dataZoom = dataZoomOpts = [dataZoomOpts];\n  }\n\n  var toolboxOpt = option.toolbox;\n\n  if (toolboxOpt) {\n    // Assume there is only one toolbox\n    if (zrUtil.isArray(toolboxOpt)) {\n      toolboxOpt = toolboxOpt[0];\n    }\n\n    if (toolboxOpt && toolboxOpt.feature) {\n      var dataZoomOpt = toolboxOpt.feature.dataZoom;\n      addForAxis('xAxis', dataZoomOpt);\n      addForAxis('yAxis', dataZoomOpt);\n    }\n  }\n\n  function addForAxis(axisName, dataZoomOpt) {\n    if (!dataZoomOpt) {\n      return;\n    } // Try not to modify model, because it is not merged yet.\n\n\n    var axisIndicesName = axisName + 'Index';\n    var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\n    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {\n      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];\n    }\n\n    forEachComponent(axisName, function (axisOpt, axisIndex) {\n      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {\n        return;\n      }\n\n      var newOpt = {\n        type: 'select',\n        $fromToolbox: true,\n        // Id for merge mapping.\n        id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n      }; // FIXME\n      // Only support one axis now.\n\n      newOpt[axisIndicesName] = axisIndex;\n      dataZoomOpts.push(newOpt);\n    });\n  }\n\n  function forEachComponent(mainType, cb) {\n    var opts = option[mainType];\n\n    if (!zrUtil.isArray(opts)) {\n      opts = opts ? [opts] : [];\n    }\n\n    each(opts, cb);\n  }\n});\nvar _default = DataZoom;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n// module id = 2447\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushController.js\n// module id = 2448\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\n// module id = 2449\n// module chunks = 2","var BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _cursorHelper = require(\"./cursorHelper\");\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar graphicUtil = require(\"../../util/graphic\");\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints, transform) {\n    return graphicUtil.clipPointsByRect(localPoints, rect);\n  };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  rect = normalizeRect(rect);\n  return function (e, localCursorPoint, transform) {\n    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\n\nfunction normalizeRect(rect) {\n  return BoundingRect.create(rect);\n}\n\nexports.makeRectPanelClipPath = makeRectPanelClipPath;\nexports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;\nexports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/brushHelper.js\n// module id = 2450\n// module chunks = 2","var IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;\n}\n\nexports.onIrrelevantElement = onIrrelevantElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/cursorHelper.js\n// module id = 2451\n// module chunks = 2","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SelectZoomModel\");\n\nrequire(\"./dataZoom/SelectZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoomSelect.js\n// module id = 2452\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n// module id = 2453\n// module chunks = 2","var DataZoomView = require(\"./DataZoomView\");\n\nvar _default = DataZoomView.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n// module id = 2454\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n  this.model = model;\n}\n\nRestore.defaultOption = {\n  show: true,\n  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n  title: restoreLang.title\n};\nvar proto = Restore.prototype;\n\nproto.onclick = function (ecModel, api, type) {\n  history.clear(ecModel);\n  api.dispatchAction({\n    type: 'restore',\n    from: this.uid\n  });\n};\n\nfeatureManager.register('restore', Restore);\necharts.registerAction({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\nvar _default = Restore;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n// module id = 2455\n// module chunks = 2","var echarts = require(\"../echarts\");\n\nrequire(\"./marker/MarkPointModel\");\n\nrequire(\"./marker/MarkPointView\");\n\n// HINT Markpoint can't be used too much\necharts.registerPreprocessor(function (opt) {\n  // Make sure markPoint component is enabled\n  opt.markPoint = opt.markPoint || {};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/markPoint.js\n// module id = 2456\n// module chunks = 2","var MarkerModel = require(\"./MarkerModel\");\n\nvar _default = MarkerModel.extend({\n  type: 'markPoint',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    //symbolRotate: 0,\n    //symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'inside'\n    },\n    itemStyle: {\n      borderWidth: 2\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointModel.js\n// module id = 2457\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar dataFormatMixin = require(\"../../model/mixin/dataFormat\");\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerModel.js\n// module id = 2458\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../../chart/helper/SymbolDraw\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar List = require(\"../../data/List\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar MarkerView = require(\"./MarkerView\");\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar _default = MarkerView.extend({\n  type: 'markPoint',\n  // updateLayout: function (markPointModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mpModel = seriesModel.markPointModel;\n  //         if (mpModel) {\n  //             updateMarkerLayout(mpModel.getData(), seriesModel, api);\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = seriesModel.markPointModel;\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbolSize = itemModel.getShallow('symbolSize');\n\n      if (typeof symbolSize === 'function') {\n        // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));\n      }\n\n      mpData.setItemVisual(idx, {\n        symbolSize: symbolSize,\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'),\n        symbol: itemModel.getShallow('symbol')\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        child.dataModel = mpModel;\n      });\n    });\n    symbolDraw.__keep = true;\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new List(coordDimsInfos, mpModel);\n  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointView.js\n// module id = 2459\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim, otherDataDim);\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/markerHelper.js\n// module id = 2460\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerView.js\n// module id = 2461\n// module chunks = 2"],"sourceRoot":""}